This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*.ts, tests/**/*.ts, docs/*.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
docs/CATALOGUE.md
docs/CIRCUIT_JSON_PCB_OVERVIEW.md
docs/CIRCUIT_JSON_SCHEMATIC_COMPONENT_OVERVIEW.md
docs/CREATING_NEW_COMPONENTS.md
docs/DEVELOPMENT.md
docs/RENDER_PHASES.md
docs/RENDERING_RULES_AND_GUIDELINES.md
docs/TSCIRCUIT_REACT_PROPS_OVERVIEW.md
docs/WRITING_TESTS.md
src/fn/axial.ts
src/fn/bga.ts
src/fn/breakoutheaders.ts
src/fn/cap.ts
src/fn/dfn.ts
src/fn/diode.ts
src/fn/dip.ts
src/fn/hc49.ts
src/fn/index.ts
src/fn/led.ts
src/fn/lqfp.ts
src/fn/melf.ts
src/fn/micromelf.ts
src/fn/minimelf.ts
src/fn/mlp.ts
src/fn/ms012.ts
src/fn/ms013.ts
src/fn/pad.ts
src/fn/pinrow.ts
src/fn/pushbutton.ts
src/fn/qfn.ts
src/fn/qfp.ts
src/fn/quad.ts
src/fn/res.ts
src/fn/sma.ts
src/fn/smb.ts
src/fn/smc.ts
src/fn/smf.ts
src/fn/sod110.ts
src/fn/sod123.ts
src/fn/sod123f.ts
src/fn/sod123w.ts
src/fn/sod128.ts
src/fn/sod323.ts
src/fn/sod323f.ts
src/fn/sod523.ts
src/fn/sod723.ts
src/fn/sod882.ts
src/fn/sod882d.ts
src/fn/sod923.ts
src/fn/soic.ts
src/fn/sop8.ts
src/fn/sot223.ts
src/fn/sot23.ts
src/fn/sot363.ts
src/fn/sot563.ts
src/fn/sot723.ts
src/fn/sot89.ts
src/fn/ssop.ts
src/fn/stampboard.ts
src/fn/stampreceiver.ts
src/fn/to220.ts
src/fn/to92.ts
src/fn/tssop.ts
src/fn/vssop8.ts
src/footprinter.ts
src/helpers/corner.ts
src/helpers/get-quad-pin-map.ts
src/helpers/is-not-null.ts
src/helpers/passive-fn.ts
src/helpers/platedhole.ts
src/helpers/rectpad.ts
src/helpers/silkscreenpath.ts
src/helpers/silkscreenRef.ts
src/helpers/u-curve.ts
src/helpers/zod/ALPHABET.ts
src/helpers/zod/AnyFootprinterDefinitionOutput.ts
src/helpers/zod/dim-2d.ts
src/helpers/zod/function-call.ts
src/helpers/zod/now-defined.ts
src/helpers/zod/pin-order-specifier.ts
src/index.ts
tests/axial.test.ts
tests/bga.test.ts
tests/breakoutheaders.test.ts
tests/cap.test.ts
tests/dfn.test.ts
tests/diode.test.ts
tests/dip.test.ts
tests/fixtures/get-test-fixture.ts
tests/fixtures/index.ts
tests/fixtures/preload.ts
tests/footprint-completeness.test.ts
tests/fp-string-error.test.ts
tests/get-footprint-names.test.ts
tests/hc49.test.ts
tests/led.test.ts
tests/lqfp.test.ts
tests/melf.test.ts
tests/micromelf.test.ts
tests/minimelf.test.ts
tests/mlp.test.ts
tests/ms012.test.ts
tests/ms013.test.ts
tests/pad.test.ts
tests/pinrow.test.ts
tests/pushbutton.test.ts
tests/qfn.test.ts
tests/qfp.test.ts
tests/quad-custom-thermalpad.test.ts
tests/quad.test.ts
tests/res.test.ts
tests/slop/slop1.test.ts
tests/sma.test.ts
tests/smb.test.ts
tests/smc.test.ts
tests/smf.test.ts
tests/sod110.test.ts
tests/sod123.test.ts
tests/sod123f.test.ts
tests/sod123w.test.ts
tests/sod128.test.ts
tests/sod323.test.ts
tests/sod323f.test.ts
tests/sod523.test.ts
tests/sod723.test.ts
tests/sod882.test.ts
tests/sod882d.test.ts
tests/sod923.test.ts
tests/soic.test.ts
tests/sop8.test.ts
tests/sot223.test.ts
tests/sot23.test.ts
tests/sot363.test.ts
tests/sot563.test.ts
tests/sot723.test.ts
tests/sot89.test.ts
tests/ssop.test.ts
tests/stampboard.test.ts
tests/stampreceiver.test.ts
tests/to220.test.ts
tests/to92.test.ts
tests/tssop.test.ts
tests/vssop8.test.ts

================================================================
Files
================================================================

================
File: docs/CATALOGUE.md
================
# @tscircuit/core Catalogue

The catalogue pattern is used to register components with the ReactFiber reconciler

If your component is exported from `lib/components/index.ts`, it will be registered
automatically when the library is used because of the `lib/register-catalogue.ts` file.

The catalogue is a way to make tscircuit more extensible (because new components can
be registered in the catalogue) and avoids circular dependencies because the
catalogue is dynamically registered, so the react-fiber layer doesn't need to
import the components.

================
File: docs/CIRCUIT_JSON_PCB_OVERVIEW.md
================
# Circuit JSON Specification: PCB Component Overview

> Created at 2024-10-23T22:17:25.274Z
> Latest Version: https://github.com/tscircuit/circuit-json/blob/main/docs/PCB_COMPONENT_OVERVIEW.md

Any type below can be imported from `circuit-json`. Every type has a corresponding
snake_case version which is a zod type that can be used to parse unknown json,
for example `PcbComponent` has a `pcb_component.parse` function that you
can also import.

```ts
export interface PcbFabricationNotePath {
  type: "pcb_fabrication_note_path"
  pcb_fabrication_note_path_id: string
  pcb_component_id: string
  layer: LayerRef
  route: Point[]
  stroke_width: Length
  color?: string
}

export interface PcbComponent {
  type: "pcb_component"
  pcb_component_id: string
  source_component_id: string
  center: Point
  layer: LayerRef
  rotation: Rotation
  width: Length
  height: Length
}

export interface PcbPortNotMatchedError {
  type: "pcb_port_not_matched_error"
  pcb_error_id: string
  message: string
  pcb_component_ids: string[]
}

export interface PcbSolderPasteCircle {
  type: "pcb_solder_paste"
  shape: "circle"
  pcb_solder_paste_id: string
  x: Distance
  y: Distance
  radius: number
  layer: LayerRef
  pcb_component_id?: string
  pcb_smtpad_id?: string
}

export interface PcbSolderPasteRect {
  type: "pcb_solder_paste"
  shape: "rect"
  pcb_solder_paste_id: string
  x: Distance
  y: Distance
  width: number
  height: number
  layer: LayerRef
  pcb_component_id?: string
  pcb_smtpad_id?: string
}

export type PcbSolderPaste = PcbSolderPasteCircle | PcbSolderPasteRect

export interface PcbSilkscreenText {
  type: "pcb_silkscreen_text"
  pcb_silkscreen_text_id: string
  font: "tscircuit2024"
  font_size: Length
  pcb_component_id: string
  text: string
  layer: LayerRef
  is_mirrored?: boolean
  anchor_position: Point
  anchor_alignment:
    | "center"
    | "top_left"
    | "top_right"
    | "bottom_left"
    | "bottom_right"
}

export interface PcbTraceError {
  type: "pcb_trace_error"
  pcb_trace_error_id: string
  error_type: "pcb_trace_error"
  message: string
  center?: Point
  pcb_trace_id: string
  source_trace_id: string
  pcb_component_ids: string[]
  pcb_port_ids: string[]
}

export interface PcbSilkscreenPill {
  type: "pcb_silkscreen_pill"
  pcb_silkscreen_pill_id: string
  pcb_component_id: string
  center: Point
  width: Length
  height: Length
  layer: LayerRef
}

export interface PcbPlatedHoleCircle {
  type: "pcb_plated_hole"
  shape: "circle"
  outer_diameter: number
  hole_diameter: number
  x: Distance
  y: Distance
  layers: LayerRef[]
  port_hints?: string[]
  pcb_component_id?: string
  pcb_port_id?: string
  pcb_plated_hole_id: string
}

export interface PcbPlatedHoleOval {
  type: "pcb_plated_hole"
  shape: "oval" | "pill"
  outer_width: number
  outer_height: number
  hole_width: number
  hole_height: number
  x: Distance
  y: Distance
  layers: LayerRef[]
  port_hints?: string[]
  pcb_component_id?: string
  pcb_port_id?: string
  pcb_plated_hole_id: string
}

export type PcbPlatedHole = PcbPlatedHoleCircle | PcbPlatedHoleOval

export interface PcbFabricationNoteText {
  type: "pcb_fabrication_note_text"
  pcb_fabrication_note_text_id: string
  font: "tscircuit2024"
  font_size: Length
  pcb_component_id: string
  text: string
  layer: VisibleLayer
  anchor_position: Point
  anchor_alignment:
    | "center"
    | "top_left"
    | "top_right"
    | "bottom_left"
    | "bottom_right"
  color?: string
}

export interface PcbSilkscreenCircle {
  type: "pcb_silkscreen_circle"
  pcb_silkscreen_circle_id: string
  pcb_component_id: string
  center: Point
  radius: Length
  layer: VisibleLayer
}

export interface PcbSilkscreenPath {
  type: "pcb_silkscreen_path"
  pcb_silkscreen_path_id: string
  pcb_component_id: string
  layer: VisibleLayerRef
  route: Point[]
  stroke_width: Length
}

export interface PcbText {
  type: "pcb_text"
  pcb_text_id: string
  text: string
  center: Point
  layer: LayerRef
  width: Length
  height: Length
  lines: number
  align: "bottom-left"
}

export interface PCBKeepout {
  type: "pcb_keepout"
  shape: "rect" | "circle"
  center: Point
  width?: Distance
  height?: Distance
  radius?: Distance
  pcb_keepout_id: string
  layers: string[]
  description?: string
}

export interface PcbVia {
  type: "pcb_via"
  pcb_via_id: string
  x: Distance
  y: Distance
  outer_diameter: Distance
  hole_diameter: Distance
  layers: LayerRef[]
  pcb_trace_id?: string
}

export interface PcbSilkscreenOval {
  type: "pcb_silkscreen_oval"
  pcb_silkscreen_oval_id: string
  pcb_component_id: string
  center: Point
  radius_x: Distance
  radius_y: Distance
  layer: VisibleLayer
}

export interface PcbManualEditConflictError {
  type: "pcb_manual_edit_conflict_error"
  pcb_manual_edit_conflict_error_id: string
  message: string
  pcb_component_id: string
  source_component_id: string
}

export interface PcbPlacementError {
  type: "pcb_placement_error"
  pcb_placement_error_id: string
  message: string
}

export interface PcbPort {
  type: "pcb_port"
  pcb_port_id: string
  source_port_id: string
  pcb_component_id: string
  x: Distance
  y: Distance
  layers: LayerRef[]
}

export interface PcbSmtPadCircle {
  type: "pcb_smtpad"
  shape: "circle"
  pcb_smtpad_id: string
  x: Distance
  y: Distance
  radius: number
  layer: LayerRef
  port_hints?: string[]
  pcb_component_id?: string
  pcb_port_id?: string
}

export interface PcbSmtPadRect {
  type: "pcb_smtpad"
  shape: "rect"
  pcb_smtpad_id: string
  x: Distance
  y: Distance
  width: number
  height: number
  layer: LayerRef
  port_hints?: string[]
  pcb_component_id?: string
  pcb_port_id?: string
}

export type PcbSmtPad = PcbSmtPadCircle | PcbSmtPadRect

export interface PcbSilkscreenLine {
  type: "pcb_silkscreen_line"
  pcb_silkscreen_line_id: string
  pcb_component_id: string
  stroke_width: Distance
  x1: Distance
  y1: Distance
  x2: Distance
  y2: Distance
  layer: VisibleLayer
}

export interface PcbHoleCircleOrSquare {
  type: "pcb_hole"
  pcb_hole_id: string
  hole_shape: "circle" | "square"
  hole_diameter: number
  x: Distance
  y: Distance
}

export interface PcbHoleOval {
  type: "pcb_hole"
  pcb_hole_id: string
  hole_shape: "oval"
  hole_width: number
  hole_height: number
  x: Distance
  y: Distance
}

export type PcbHole = PcbHoleCircleOrSquare | PcbHoleOval

export interface PcbTraceRoutePointWire {
  route_type: "wire"
  x: Distance
  y: Distance
  width: Distance
  start_pcb_port_id?: string
  end_pcb_port_id?: string
  layer: LayerRef
}

export interface PcbTraceRoutePointVia {
  route_type: "via"
  x: Distance
  y: Distance
  from_layer: string
  to_layer: string
}

export type PcbTraceRoutePoint = PcbTraceRoutePointWire | PcbTraceRoutePointVia

export interface PcbTrace {
  type: "pcb_trace"
  source_trace_id?: string
  pcb_component_id?: string
  pcb_trace_id: string
  route_order_index?: number
  route_thickness_mode?: "constant" | "interpolated"
  should_round_corners?: boolean
  route: Array<PcbTraceRoutePoint>
}

export interface PcbBoard {
  type: "pcb_board"
  pcb_board_id: string
  width: Length
  height: Length
  thickness: Length
  num_layers: number
  center: Point
  outline?: Point[]
}
```

================
File: docs/CIRCUIT_JSON_SCHEMATIC_COMPONENT_OVERVIEW.md
================
# Circuit JSON Specification: Schematic Component Overview

> Created at 2024-10-23T22:29:08.481Z
> Latest Version: https://github.com/tscircuit/circuit-json/blob/main/docs/SCHEMATIC_COMPONENT_OVERVIEW.md

Any type below can be imported from `circuit-json`. Every type has a corresponding
snake_case version which is a zod type that can be used to parse unknown json,
for example `SchematicComponent` has a `schematic_component.parse` function that you
can also import.

```ts
interface SchematicTrace {
  type: "schematic_trace"
  schematic_trace_id: string
  source_trace_id: string
  edges: Array<{
    from: {
      x: number
      y: number
    }
    to: {
      x: number
      y: number
    }
    from_schematic_port_id?: string
    to_schematic_port_id?: string
  }>
}

interface SchematicBox {
  type: "schematic_box"
  schematic_component_id: string
  width: number
  height: number
  x: number
  y: number
}

interface SchematicLine {
  type: "schematic_line"
  schematic_component_id: string
  x1: number
  x2: number
  y1: number
  y2: number
}

interface SchematicError {
  schematic_error_id: string
  type: "schematic_error"
  error_type: "schematic_port_not_found"
  message: string
}

interface SchematicComponent {
  type: "schematic_component"
  rotation: number
  size: { width: number; height: number }
  center: { x: number; y: number }
  source_component_id: string
  schematic_component_id: string
  pin_spacing?: number
  pin_styles?: Record<
    string,
    {
      left_margin?: number
      right_margin?: number
      top_margin?: number
      bottom_margin?: number
    }
  >
  box_width?: number
  symbol_name?: string
  port_arrangement?:
    | {
        left_size: number
        right_size: number
        top_size?: number
        bottom_size?: number
      }
    | {
        left_side?: {
          pins: number[]
          direction?: "top-to-bottom" | "bottom-to-top"
        }
        right_side?: {
          pins: number[]
          direction?: "top-to-bottom" | "bottom-to-top"
        }
        top_side?: {
          pins: number[]
          direction?: "left-to-right" | "right-to-left"
        }
        bottom_side?: {
          pins: number[]
          direction?: "left-to-right" | "right-to-left"
        }
      }
  port_labels?: Record<string, string>
}

interface SchematicDebugRect {
  type: "schematic_debug_object"
  label?: string
  shape: "rect"
  center: { x: number; y: number }
  size: { width: number; height: number }
}

interface SchematicDebugLine {
  type: "schematic_debug_object"
  label?: string
  shape: "line"
  start: { x: number; y: number }
  end: { x: number; y: number }
}

type SchematicDebugObject = SchematicDebugRect | SchematicDebugLine

interface SchematicPort {
  type: "schematic_port"
  schematic_port_id: string
  source_port_id: string
  schematic_component_id?: string
  center: { x: number; y: number }
  facing_direction?: "up" | "down" | "left" | "right"
}

interface SchematicNetLabel {
  type: "schematic_net_label"
  source_net_id: string
  center: { x: number; y: number }
  anchor_side: "top" | "bottom" | "left" | "right"
  text: string
}

interface SchematicPath {
  type: "schematic_path"
  schematic_component_id: string
  fill_color?: "red" | "blue"
  is_filled?: boolean
  points: Array<{ x: number; y: number }>
}

interface SchematicText {
  type: "schematic_text"
  schematic_component_id: string
  schematic_text_id: string
  text: string
  position: {
    x: number
    y: number
  }
  rotation: number
  anchor: "center" | "left" | "right" | "top" | "bottom"
}
```

================
File: docs/CREATING_NEW_COMPONENTS.md
================
# Creating New Components

If you got an error like `Unsupported component type (not registered in @tscircuit/core catalogue)`, you'll probably need to create a new component.

## Steps to creating a new component

- Determine if the component is a normal component or a primitive component
  - Normal components are things like resistors, capacitors, diodes, etc.
  - Primitive components are things like traces, holes, texts, etc.
- If it's a normal component, create a new file in `lib/components/normal-components`
- If it's a primitive component, create a new file in `lib/components/primitive-components`
- Add the component to the catalogue by exporting it from the `lib/components/index.ts` file
- Add the component to the `intrinsic-jsx.ts` file
- Create a test for the component

## Getting Props for a Component

Component props are defined in `@tscircuit/props` like so:

```ts
import { silkscreenPathProps, type SilkscreenPathProps } from "@tscircuit/props"
```

Most components are defined the zod definition for their props.

## Implementing Render Phases

For a new component, you'll want to determine what render phases need to be implemented.

For something like a PCB primitive, you might only need to implement a phase like `doInitialPcbPrimitiveRender`. Look for a similar component to copy/understand what needs to be implemented. For example

## Writing a Test

Every new component should have a test written for it. This test should be in `tests/components/` and should be named `<component-name>.test.tsx`.

Usually a test for a new component has a very simple test definition like this:

```tsx
import { test, expect } from "bun:test"
import { getTestFixture } from "tests/fixtures/get-test-fixture"

test("<mycomponent />", () => {
  const { circuit } = getTestFixture()

  circuit.add(
    <board width="10mm" height="10mm">
      <mycomponent />
    </board>
  )

  circuit.render()

  expect(circuit).toMatchPcbSnapshot(import.meta.path)
})
```

================
File: docs/DEVELOPMENT.md
================
# @tscircuit/core Development Guide

When you do...

```tsx
createInstanceFromElement(
  <resistor name="R1" resistance="10k" footprint="0402" />
)
```

...you're creating a new [Resistor](../lib/components/normal-components/Resistor.ts)
class instance.

Everything you create in React becomes a class instance.

A project contains react elements and class instances that are added to it:

```tsx
const project = new Project()

project.add(
  <board width="10mm" height="10mm">
    <resistor name="R1" resistance="10k" footprint="0402" />
  </board>
)
```

when you call `project.render()`, the project will go through a series of
rendering phases. You can see all the render phases in the [Renderable class](../lib/components/base-components/Renderable.ts)

The render phases are executed in the order in that file. Each render phase
has a specific purpose.

For each render phase, every single class instance in the project gets a call
to the `doInitial*` method for each render phase (if it's defined for the class)

For example, one of the first render phases is `SourceRender`. This is where
`source_*` [circuit json/soup elements](https://github.com/tscircuit/soup) are
added to the projects output.

The output is stored inside `project.db`, it's basically an array of circuit
json elements, but it has a bunch of utility methods added to it that make it
easier to work with. Here's an example of inserting a new source_component:

```tsx
class Resistor extends NormalComponent<typeof resistorProps> {
  doInitialSourceRender() {
    this.project.db.source_component.insert({
      ftype: "simple_resistor",
      name: "R1",
      manufacturer_part_number: "1234",
      supplier_part_numbers: ["12345"],
    })
  }
}
```

There are other things that happen for render phases, for example, when a
component is removed the `remove*` method is called in order for each render
phase e.g. `removeSourceRender`

After all the render phases are complete, you can get the full circuit json/soup
by calling `project.getCircuitJson()` or `project.getSoup()`

================
File: docs/RENDER_PHASES.md
================
# Render Phases

The render phases in @tscircuit/core are defined in the `Renderable` class (`Renderable.ts`) and executed in a specific order. Each phase has a distinct purpose in the rendering process. Here's a description of each render phase:

1. ReactSubtreesRender: Renders React subtrees within components.

2. InitializePortsFromChildren: Initializes ports based on the component's children.

3. CreateNetsFromProps: Creates nets based on the component's properties.

4. CreateTracesFromProps: Creates traces based on the component's properties.

5. SourceRender: Renders the source component, which is the basic representation of the component.

6. SourceParentAttachment: Attaches the source component to its parent.

7. PortMatching: Matches ports with their corresponding elements.

8. SourceTraceRender: Renders the source traces, which are the basic representations of connections between components.

9. SchematicComponentRender: Renders the schematic representation of the component.

10. SchematicLayout: Handles the layout of schematic components.

11. SchematicPortRender: Renders ports in the schematic view.

12. SchematicTraceRender: Renders traces in the schematic view.

13. PcbInsertTraceHints: Inserts trace hints into the PCB from "manual trace hints" or other props that imply trace hints

14. PcbComponentRender: Renders the PCB representation of the component.

15. PcbPrimitiveRender: Renders primitive PCB elements (e.g., pads, holes).

16. PcbFootprintLayout: Handles the layout of PCB footprints.

17. PcbPortRender: Renders ports in the PCB view.

18. PcbPortAttachment: Attaches ports to their corresponding PCB elements.

19. PcbLayout: Handles the overall layout of PCB components.

20. PcbTraceRender: Renders traces in the PCB view.

21. PcbTraceHintRender: Renders trace hints in the PCB view.

22. PcbRouteNetIslands: Routes connections between isolated net islands on the PCB.

23. PcbComponentSizeCalculation: Calculates the size of PCB components.

24. CadModelRender: Renders 3D CAD models of components.

Each of these phases is executed in order for every component in the project during the rendering process. Components can implement specific logic for each phase by defining methods like `doInitial<PhaseName>`, `update<PhaseName>`, or `remove<PhaseName>`.

================
File: docs/RENDERING_RULES_AND_GUIDELINES.md
================
# Rendering Rules and Guidelines

## 1. Don't mutate `db` outside of render phases

The `db` is the mutable Circuit Json array. It is often changed and refreshed, and because of that it is
very easy to create bugs when you change it. To prevent this, we're very careful with code that mutates
the `db`

If your method mutates the database in some way, make sure it's named appropriately. A function like
`compute*` or `get*` should never mutate the `db` because the prefix `compute*` and `get*` implies they
are immutable.


## 2. Understand beforeLayout transforms

Before a circuit is laid out, positions of components are calculated using `computeSchematicGlobalTransform` (or
`computePcbGlobalTransform` for PCBs), these methods are very simple. They basically say "the current position is `parentTransform ⊕ propsTransform`"

The `parentTransform` is any translation or rotations that are due to parents. For example, a `<resistor />` in a
`<group />` will be translated by whatever the `<group />`'s `pcbX/pcbY` or `schX/schY` are.

The `propsTransform` is the transform from the props, examining your own `pcbX/pcbY`

These methods are called recursively, that way you can have a `<group />` in another `<group />`. The `parentTransform`
contains the sum of all ancestor transforms!

For both PCBs and Schematics, the schematic or PCB is laid out using the `beforeLayout` positions, then a render phase phase
like `SchematicLayout` is run to move components according to the layout position.

================
File: docs/TSCIRCUIT_REACT_PROPS_OVERVIEW.md
================
# @tscircuit/props Overview

> Generated at 2024-10-24T23:36:55.414Z

This document provides an overview of all the prop types available in @tscircuit/props.
Each interface has a corresponding zod validator that can be imported from the package.

For example, for `ChipProps` there is a `chipProps` zod validator:

```ts
import { chipProps, type ChipProps } from "@tscircuit/props"

// Validate/parse props
const validatedProps = chipProps.parse(unknownProps)
```

## Available Props

```ts
export interface JumperProps extends CommonComponentProps {
  manufacturerPartNumber?: string
  pinLabels?: Record<number | string, string>
  schPinStyle?: SchematicPinStyle
  schPinSpacing?: number | string
  schWidth?: number | string
  schHeight?: number | string
  schDirection?: "left" | "right"
  schPortArrangement?: SchematicPortArrangement
}


export interface ResistorProps extends CommonComponentProps {
  resistance: number | string
  pullupFor?: string
  pullupTo?: string
  pulldownFor?: string
  pulldownTo?: string
}


export interface CirclePlatedHoleProps
  extends Omit<PcbLayoutProps, "pcbRotation" | "layer"> {
  name?: string
  shape: "circle"
  holeDiameter: number | string
  outerDiameter: number | string
  portHints?: PortHints
}


export interface OvalPlatedHoleProps
  extends Omit<PcbLayoutProps, "pcbRotation" | "layer"> {
  name?: string
  shape: "oval"
  outerWidth: number | string
  outerHeight: number | string
  innerWidth: number | string
  innerHeight: number | string
  portHints?: PortHints
}


export interface PillPlatedHoleProps
  extends Omit<PcbLayoutProps, "pcbRotation" | "layer"> {
  name?: string
  shape: "pill"
  outerWidth: number | string
  outerHeight: number | string
  innerWidth: number | string
  innerHeight: number | string
  portHints?: PortHints
}


export interface BaseGroupProps extends CommonLayoutProps {
  name?: string
  children?: any
}


export interface SubcircuitGroupProps extends BaseGroupProps {
  subcircuit: true
  layout?: LayoutBuilder
  routingDisabled?: boolean
  defaultTraceWidth?: Distance

  /**
   * If true, we'll automatically layout the schematic for this group. Must be
   * a subcircuit (currently). This is eventually going to be replaced with more
   * sophisticated layout options/modes and will be enabled by default.
   */
  schAutoLayoutEnabled?: boolean
}


export interface RectSolderPasteProps
  extends Omit<PcbLayoutProps, "pcbRotation"> {
  shape: "rect"
  width: Distance
  height: Distance
}


export interface CircleSolderPasteProps
  extends Omit<PcbLayoutProps, "pcbRotation"> {
  shape: "circle"
  radius: Distance
}


export interface CapacitorProps extends CommonComponentProps {
  capacitance: number | string

  decouplingFor?: string
  decouplingTo?: string

  bypassFor?: string
  bypassTo?: string
}


export interface RectSmtPadProps extends Omit<PcbLayoutProps, "pcbRotation"> {
  shape: "rect"
  width: Distance
  height: Distance
  portHints?: PortHints
}


export interface CircleSmtPadProps extends Omit<PcbLayoutProps, "pcbRotation"> {
  shape: "circle"
  radius: Distance
  portHints?: PortHints
}


export interface NetProps {
  name: string
}


export interface ChipProps extends CommonComponentProps {
  manufacturerPartNumber?: string
  pinLabels?: Record<number | string, string | string[]>
  schPortArrangement?: SchematicPortArrangement
  schPinStyle?: SchematicPinStyle
  schPinSpacing?: Distance
  schWidth?: Distance
  schHeight?: Distance
}


export interface BatteryProps extends CommonComponentProps {
  capacity?: number | string
}


export interface FootprintProps {
  /**
   * The layer that the footprint is designed for. If you set this to "top"
   * then it means the children were intended to represent the top layer. If
   * the <chip /> with this footprint is moved to the bottom layer, then the
   * components will be mirrored.
   *
   * Generally, you shouldn't set this except where it can help prevent
   * confusion because you have a complex multi-layer footprint. Default is
   * "top" and this is most intuitive.
   */
  originalLayer?: LayerRef
}


export interface HoleProps extends Omit<PcbLayoutProps, "pcbRotation"> {
  name?: string
  diameter?: Distance
  radius?: Distance
}


export interface ConstrainedLayoutProps {
  name?: string
  pcbOnly?: boolean
  schOnly?: boolean
}


export interface BoardProps {
  width?: number | string
  height?: number | string
  outline?: Point[]
  pcbX?: number | string
  pcbY?: number | string
  layout?: any
  routingDisabled?: boolean
  children?: any
  defaultTraceWidth?: Distance
  /**
   * If true, we'll automatically layout the schematic for this group. Must be
   * a subcircuit (currently). This is eventually going to be replaced with more
   * sophisticated layout options/modes and will be enabled by default.
   */
  schAutoLayoutEnabled?: boolean
}


export interface CadModelBase {
  rotationOffset?:
    | number
    | { x: number | string; y: number | string; z: number | string }
  positionOffset?: {
    x: number | string
    y: number | string
    z: number | string
  }
  size?: { x: number | string; y: number | string; z: number | string }
}


export interface CadModelStl extends CadModelBase {
  stlUrl: string
}


export interface CadModelObj extends CadModelBase {
  objUrl: string
  mtlUrl?: string
}


export interface CadModelJscad extends CadModelBase {
  jscad: Record<string, any>
}


export interface PcbLayoutProps {
  pcbX?: string | number
  pcbY?: string | number
  pcbRotation?: string | number
  layer?: LayerRefInput
}


export interface CommonLayoutProps {
  pcbX?: string | number
  pcbY?: string | number
  pcbRotation?: string | number

  schX?: string | number
  schY?: string | number
  schRotation?: string | number

  layer?: LayerRefInput
  footprint?: Footprint
}


export interface SupplierProps {
  supplierPartNumbers?: { [k in SupplierName]?: string[] }
}


export interface CommonComponentProps extends CommonLayoutProps {
  key?: any
  name: string
  supplierPartNumbers?: SupplierProps["supplierPartNumbers"]
  cadModel?: CadModelProp
  children?: any
  symbolName?: string
}


export interface SchematicPortArrangementWithSizes {
  leftSize?: number
  topSize?: number
  rightSize?: number
  bottomSize?: number
}


export interface SchematicPortArrangementWithPinCounts {
  leftPinCount?: number
  topPinCount?: number
  rightPinCount?: number
  bottomPinCount?: number
}


export interface PinSideDefinition {
  pins: number[]
  direction:
    | "top-to-bottom"
    | "left-to-right"
    | "bottom-to-top"
    | "right-to-left"
}


export interface SchematicPortArrangementWithSides {
  leftSide?: PinSideDefinition
  topSide?: PinSideDefinition
  rightSide?: PinSideDefinition
  bottomSide?: PinSideDefinition
}

```

================
File: docs/WRITING_TESTS.md
================
# Writing Tests

This is the basic template for any test:

```tsx
import { test, expect } from "bun:test"
import { getTestFixture } from "tests/fixtures/get-test-fixture"

test("my test name", async () => {
  const { circuit } = getTestFixture()

  circuit.add(
    <board width="12mm" height="10mm">
      {/*
        add components here e.g.
        <chip
          name="U1"
          footprint="soic8"
          pinLabels={{ pin1: "PWR", pin8: "GND" }}
          pcbX={0}
          pcbY={0}
        />
      */}
    </board>
  )

  circuit.render()

  // optional: add expect statements that query against classes
  // expect(circuit.selectAll("trace").length).toBe(7)

  // optional: add expect statements here to check for expected values
  // expect(circuit.db.pcb_smtpad.list().map((smtpad) => smtpad.pcb_port_id)).not.toContain(null)
  // expect(circuit.db.pcb_plated_hole.list()[0].hole_diameter).toBe(0.4)

  expect(circuit).toMatchPcbSnapshot(import.meta.path)
})
```

After running the test the first time, an svg snapshot will be created.

================
File: src/fn/axial.ts
================
import {
  length,
  type AnySoupElement,
  type PcbSilkscreenLine,
  type PcbSilkscreenPath,
} from "circuit-json"
import { passive, type PassiveDef } from "../helpers/passive-fn"
import { z } from "zod"
import { platedhole } from "src/helpers/platedhole"
import { silkscreenRef, type SilkscreenRef } from "../helpers/silkscreenRef"

export const axial_def = z.object({
  fn: z.string(),
  p: length.optional().default("2.54mm"),
  id: length.optional().default("0.7mm"),
  od: length.optional().default("1mm"),
})
export type AxialDef = z.input<typeof axial_def>

export const axial = (
  raw_params: AxialDef,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = axial_def.parse(raw_params)

  const { p, id, od } = parameters

  const plated_holes = [
    platedhole(1, -p / 2, 0, id, od),
    platedhole(2, p / 2, 0, id, od),
  ]

  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: -p / 2 + od + id / 2, y: 0 },
      { x: p / 2 - od - id / 2, y: 0 },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }
  const silkscreenRefText: SilkscreenRef = silkscreenRef(0, p / 4, 0.5)
  return {
    circuitJson: [
      ...plated_holes,
      silkscreenLine,
      silkscreenRefText as AnySoupElement,
    ],
    parameters,
  }
}

================
File: src/fn/bga.ts
================
import type { AnySoupElement, PCBSMTPad } from "circuit-json"
import { rectpad } from "../helpers/rectpad"
import { ALPHABET } from "../helpers/zod/ALPHABET"
import { z } from "zod"
import { length, distance } from "circuit-json"
import { dim2d } from "src/helpers/zod/dim-2d"
import { function_call } from "src/helpers/zod/function-call"
import type { NowDefined } from "src/helpers/zod/now-defined"
import { type SilkscreenRef, silkscreenRef } from "src/helpers/silkscreenRef"

export const bga_def = z
  .object({
    fn: z.string(),
    num_pins: z.number().optional().default(64),
    grid: dim2d.optional(),
    p: distance.default("0.8mm"),
    w: length.optional(),
    h: length.optional(),
    ball: length.optional().describe("ball diameter"),
    pad: length.optional().describe("pad width/height"),

    tlorigin: z.boolean().optional(),
    blorigin: z.boolean().optional(),
    trorigin: z.boolean().optional(),
    brorigin: z.boolean().optional(),

    missing: function_call.default([]),
  })
  .transform((a) => {
    let origin: "tl" | "bl" | "tr" | "br" = "tl"
    if (a.blorigin) origin = "bl"
    if (a.trorigin) origin = "tr"
    if (a.brorigin) origin = "br"

    if (!a.grid) {
      // find the largest square for the number of pins
      const largest_square = Math.ceil(Math.sqrt(a.num_pins))
      a.grid = { x: largest_square, y: largest_square }
    }

    if (a.missing) {
      a.missing = a.missing.map((s) => {
        if (typeof s === "number") return s
        if (s === "center") return "center"
        if (s === "topleft") return "topleft"
        const m = s.match(/([A-Z]+)(\d+)/)
        if (!m) return s
        const Y = ALPHABET.indexOf(m[1]!)
        const X = Number.parseInt(m[2]!) - 1
        return Y * a.grid!.x + X + 1
      })
    }

    const new_def = { ...a, origin }

    return new_def as NowDefined<typeof new_def, "w" | "h" | "grid">
  })

export type BgaDefInput = z.input<typeof bga_def>
export type BgaDef = z.infer<typeof bga_def>

export const bga = (
  raw_params: BgaDefInput,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = bga_def.parse(raw_params)
  let { num_pins, grid, p, w, h, ball, pad, missing } = parameters

  ball ??= (0.75 / 1.27) * p

  pad ??= ball * 0.8

  const pads: PCBSMTPad[] = []

  const missing_pin_nums = (missing ?? []).filter((a) => typeof a === "number")
  const num_pins_missing = grid.x * grid.y - num_pins

  if (missing.length === 0 && num_pins_missing > 0) {
    // No missing pins specified, let's see if a squared center works
    // if num_pins_missing is a square
    if (Math.sqrt(num_pins_missing) % 1 === 0) {
      missing.push("center")
    } else if (num_pins_missing === 1) {
      missing.push("topleft")
    }
  }

  if (missing?.includes("center")) {
    // Find the largest square that's square is less than
    // the number of missing pins
    const square_size = Math.floor(Math.sqrt(num_pins_missing))

    // Find the top left coordinate of the inner square, keep
    // in mind the full grid size is grid.x x grid.y
    const inner_square_x = Math.floor((grid.x - square_size) / 2)
    const inner_square_y = Math.floor((grid.y - square_size) / 2)

    // Add all the missing square pin numbers to missing_pin_nums
    for (let y = inner_square_y; y < inner_square_y + square_size; y++) {
      for (let x = inner_square_x; x < inner_square_x + square_size; x++) {
        missing_pin_nums.push(y * grid.x + x + 1)
      }
    }
  }

  if (missing?.includes("topleft")) {
    missing_pin_nums.push(1)
  }

  const missing_pin_nums_set = new Set(missing_pin_nums)

  let missing_pins_passed = 0
  for (let y = 0; y < grid.y; y++) {
    for (let x = 0; x < grid.x; x++) {
      let pin_num = y * grid.x + x + 1
      if (missing_pin_nums_set.has(pin_num)) {
        missing_pins_passed++
        continue
      }
      pin_num -= missing_pins_passed

      const pad_x = (x - (grid.x - 1) / 2) * p
      const pad_y = -(y - (grid.y - 1) / 2) * p

      // TODO handle >26 rows
      pads.push(
        rectpad([pin_num, `${ALPHABET[y]}${x + 1}`], pad_x, pad_y, pad, pad),
      )
    }
  }
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    (grid.y * p) / 2,
    0.2,
  )

  return {
    circuitJson: [...pads, silkscreenRefText as AnySoupElement],
    parameters,
  }
}

================
File: src/fn/breakoutheaders.ts
================
import {
  length,
  type AnyCircuitElement,
  type PcbPlatedHole,
  type PcbSilkscreenPath,
} from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { platedhole } from "src/helpers/platedhole"

export const breakoutheaders_def = z.object({
  fn: z.string(),
  w: length.default("10mm"),
  h: length.optional(),
  left: length.optional().default(20),
  right: length.optional().default(20),
  top: length.optional().default(0),
  bottom: length.optional().default(0),
  p: length.default(length.parse("2.54mm")),
  id: length.optional().default(length.parse("1mm")),
  od: length.optional().default(length.parse("1.5mm")),
})

export type breakoutheaders_def = z.input<typeof breakoutheaders_def>

const getHeight = (parameters: breakoutheaders_def): number => {
  const params = breakoutheaders_def.parse(parameters)

  // Calculate height based on the presence of left and right parameters
  if (params.left && params.right) {
    return Math.max(params.left, params.right) * params.p
  }

  if (params.left) {
    return params.left * params.p
  }

  if (params.right) {
    return params.right * params.p
  }

  return 51
}

type Point = { x: number; y: number }
type Direction = "left" | "right" | "top" | "bottom"

const getTrianglePath = (
  x: number,
  y: number,
  side: Direction,
  triangleHeight = 1,
  triangleWidth = 0.6,
): Point[] => {
  const halfHeight = triangleHeight / 2
  const halfWidth = triangleWidth / 2

  const silkscreenTriangleRoutes: Record<Direction, Point[]> = {
    left: [
      { x: x + halfHeight, y },
      { x: x - halfHeight, y: y + halfWidth },
      { x: x - halfHeight, y: y - halfWidth },
      { x: x + halfHeight, y },
    ],
    right: [
      { x: x - halfHeight, y },
      { x: x + halfHeight, y: y + halfWidth },
      { x: x + halfHeight, y: y - halfWidth },
      { x: x - halfHeight, y },
    ],
    top: [
      { x, y: y - halfHeight },
      { x: x - halfWidth, y: y + halfHeight },
      { x: x + halfWidth, y: y + halfHeight },
      { x, y: y - halfHeight },
    ],
    bottom: [
      { x, y: y + halfHeight },
      { x: x - halfWidth, y: y - halfHeight },
      { x: x + halfWidth, y: y - halfHeight },
      { x, y: y + halfHeight },
    ],
  }

  return silkscreenTriangleRoutes[side]
}
export const breakoutheaders = (
  raw_params: breakoutheaders_def,
): { circuitJson: AnyCircuitElement[]; parameters: any } => {
  const params = breakoutheaders_def.parse(raw_params)
  const height = params.h ?? getHeight(params)
  const holes: PcbPlatedHole[] = []
  const innerDiameter = params.id
  const outerDiameter = params.od
  let silkscreenTriangleRoutes: { x: number; y: number }[] = []
  if (params.right) {
    const yoff = -((params.right - 1) / 2) * params.p
    for (let i = 0; i < params.right; i++) {
      if (i === 0 && !params.left && !params.bottom) {
        silkscreenTriangleRoutes = getTrianglePath(
          params.w / 2 + outerDiameter * 1.4,
          yoff + i * params.p,
          "right",
        )
      }
      holes.push(
        platedhole(
          i + 1 + params.left + (params.bottom ?? 0),
          params.w / 2,
          yoff + i * params.p,
          innerDiameter,
          outerDiameter,
        ),
      )
    }
  }
  if (params.left) {
    const yoff = -((params.left - 1) / 2) * params.p
    for (let i = 0; i < params.left; i++) {
      if (i === params.left - 1) {
        silkscreenTriangleRoutes = getTrianglePath(
          -params.w / 2 - outerDiameter * 1.4,
          yoff + i * params.p,
          "left",
        )
      }
      holes.push(
        platedhole(
          i + 1,
          -params.w / 2,
          yoff + i * params.p,
          innerDiameter,
          outerDiameter,
        ),
      )
    }
  }
  if (params.top) {
    const xoff = -((params.top - 1) / 2) * params.p
    for (let i = 0; i < params.top; i++) {
      if (
        i === params.top - 1 &&
        !params.left &&
        !params.bottom &&
        !params.right
      ) {
        silkscreenTriangleRoutes = getTrianglePath(
          xoff + i * params.p,
          height / 2 + outerDiameter * 1.4,
          "top",
        )
      }
      holes.push(
        platedhole(
          i + 1 + params.right + (params.bottom ?? 0) + params.left,
          xoff + i * params.p,
          height / 2,
          innerDiameter,
          outerDiameter,
        ),
      )
    }
  }
  if (params.bottom) {
    const xoff = -((params.bottom - 1) / 2) * params.p
    for (let i = 0; i < params.bottom; i++) {
      if (i === 0 && !params.left) {
        silkscreenTriangleRoutes = getTrianglePath(
          xoff + i * params.p,
          -height / 2 - outerDiameter * 1.4,
          "bottom",
        )
      }
      holes.push(
        platedhole(
          i + 1 + params.left,
          xoff + i * params.p,
          -height / 2,
          innerDiameter,
          outerDiameter,
        ),
      )
    }
  }

  const silkscreenTriangle: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    pcb_silkscreen_path_id: "1",
    pcb_component_id: "1",
    layer: "top",
    route: silkscreenTriangleRoutes,
    stroke_width: 0.1,
  }

  const silkscreenPath: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    pcb_silkscreen_path_id: "pcb_silkscreen_path_1",
    pcb_component_id: "1",
    route: [
      {
        x: -params.w / 2 - outerDiameter,
        y: height / 2 + outerDiameter,
      },
      {
        x: params.w / 2 + outerDiameter,
        y: height / 2 + outerDiameter,
      },
      {
        x: params.w / 2 + outerDiameter,
        y: -height / 2 - outerDiameter,
      },
      {
        x: -params.w / 2 - outerDiameter,
        y: -height / 2 - outerDiameter,
      },
      {
        x: -params.w / 2 - outerDiameter,
        y: height / 2 + outerDiameter,
      },
    ],
    stroke_width: 0.1,
    layer: "top",
  }
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    height / 1.7,
    height / 25,
  )
  return {
    circuitJson: [
      ...holes,
      silkscreenPath,
      silkscreenRefText,
      silkscreenTriangle,
    ],
    parameters: params,
  }
}

================
File: src/fn/cap.ts
================
import type { AnySoupElement } from "circuit-json"
import { rectpad } from "../helpers/rectpad"
import { type PassiveDef, passive } from "../helpers/passive-fn"

export const cap = (
  parameters: PassiveDef,
): { circuitJson: AnySoupElement[]; parameters: PassiveDef } => {
  return { circuitJson: passive(parameters), parameters }
}

================
File: src/fn/dfn.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import {
  extendSoicDef,
  soicWithoutParsing,
  type SoicInput,
  getCcwSoicCoords,
} from "./soic"
import { rectpad } from "src/helpers/rectpad"
import { z } from "zod"
import { CORNERS } from "src/helpers/corner"
import { type SilkscreenRef, silkscreenRef } from "src/helpers/silkscreenRef"

export const dfn_def = extendSoicDef({})

/**
 * Dual Flat No-lead
 *
 * Similar to SOIC but different silkscreen
 */
export const dfn = (
  raw_params: SoicInput,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = dfn_def.parse(raw_params)
  const pads: AnySoupElement[] = []
  for (let i = 0; i < parameters.num_pins; i++) {
    const { x, y } = getCcwSoicCoords({
      num_pins: parameters.num_pins,
      pn: i + 1,
      w: parameters.w,
      p: parameters.p ?? 1.27,
      pl: parameters.pl,
      widthincludeslegs: true,
    })
    pads.push(
      rectpad(i + 1, x, y, parameters.pl ?? "1mm", parameters.pw ?? "0.6mm"),
    )
  }

  // The silkscreen is 4 corners and an arrow identifier for pin1
  const m = Math.min(1, parameters.p / 2)
  const sw = parameters.w + m
  const sh = (parameters.num_pins / 2 - 1) * parameters.p + parameters.pw + m
  const silkscreenPaths: PcbSilkscreenPath[] = []

  for (const corner of CORNERS) {
    const { dx, dy } = corner
    silkscreenPaths.push({
      layer: "top",
      pcb_component_id: "",
      pcb_silkscreen_path_id: "",
      route: [
        { x: (dx * sw) / 2 - dx * parameters.p, y: (dy * sh) / 2 },
        { x: (dx * sw) / 2, y: (dy * sh) / 2 },
        { x: (dx * sw) / 2, y: (dy * sh) / 2 - dy * parameters.p },
      ],
      type: "pcb_silkscreen_path",
      stroke_width: 0.1,
    })
  }

  // Arrow
  /** arrow size */
  const as = parameters.p / 4
  /** Arrow tip x */
  const atx = -sw / 2 - as / 2
  /** Arrow tip y */
  const aty = sh / 2 - parameters.p / 2

  silkscreenPaths.push({
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "",
    type: "pcb_silkscreen_path",
    route: [
      {
        x: atx,
        y: aty,
      },
      {
        x: atx - as,
        y: aty + as,
      },
      {
        x: atx - as,
        y: aty - as,
      },
      {
        x: atx,
        y: aty,
      },
    ],
    stroke_width: 0.1,
  })
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    sh / 2 + 0.4,
    sh / 12,
  )
  return {
    circuitJson: [
      ...pads,
      silkscreenRefText,
      ...silkscreenPaths,
    ] as AnySoupElement[],
    parameters,
  }
}

================
File: src/fn/diode.ts
================
import type { AnySoupElement } from "circuit-json"
import { passive, type PassiveDef } from "src/helpers/passive-fn"

export const diode = (parameters: {
  tht: boolean
  p: number
}): { circuitJson: AnySoupElement[]; parameters: PassiveDef } => {
  return { circuitJson: passive(parameters), parameters }
}

================
File: src/fn/dip.ts
================
import type {
  AnyCircuitElement,
  PcbFabricationNoteText,
  PcbSilkscreenPath,
} from "circuit-json"
import { type SilkscreenRef, silkscreenRef } from "src/helpers/silkscreenRef"
import { z } from "zod"
import { platedhole } from "../helpers/platedhole"
import { u_curve } from "../helpers/u-curve"
import type { NowDefined } from "../helpers/zod/now-defined"

function convertMilToMm(value: string | number): number {
  if (typeof value === "string") {
    if (value.trim().toLowerCase().endsWith("mil")) {
      // Convert mil to mm (1 mil = 0.0254 mm)
      const num = Number.parseFloat(value)
      return num * 0.0254
    }
    return Number.parseFloat(value)
  }
  return Number(value)
}

const lengthInMm = z
  .union([z.string(), z.number()])
  .transform((val) => convertMilToMm(val))

export const extendDipDef = (newDefaults: { w?: string; p?: string }) =>
  z
    .object({
      fn: z.string(),
      num_pins: z.number().optional().default(6),
      wide: z.boolean().optional(),
      narrow: z.boolean().optional(),
      w: lengthInMm.optional(),
      p: lengthInMm.default(newDefaults.p ?? "2.54mm"),
      id: lengthInMm.optional(),
      od: lengthInMm.optional(),
    })
    .transform((v) => {
      if (!v.id && !v.od) {
        // Special case for 1.27mm pitch
        if (Math.abs(v.p - 1.27) < 0.01) {
          v.id = convertMilToMm("0.55mm") // Standard hole size for 1.27mm
          v.od = convertMilToMm("0.95mm") // Standard pad size for 1.27mm
        } else {
          v.id = convertMilToMm("1.0mm")
          v.od = convertMilToMm("1.5mm")
        }
      } else if (!v.id) {
        v.id = v.od! * (1.0 / 1.5)
      } else if (!v.od) {
        v.od = v.id! * (1.5 / 1.0)
      }

      if (!v.w) {
        if (v.wide) {
          v.w = convertMilToMm("600mil")
        } else if (v.narrow) {
          v.w = convertMilToMm("300mil")
        } else {
          v.w = convertMilToMm(newDefaults.w ?? "300mil")
        }
      }
      return v as NowDefined<typeof v, "w" | "p" | "id" | "od">
    })

export const dip_def = extendDipDef({})

export const getCcwDipCoords = (
  pinCount: number,
  pn: number,
  w: number,
  p: number,
) => {
  /** pin height */
  const ph = pinCount / 2
  const isLeft = pn <= ph

  /** Number of gaps between pins on each side, e.g. 4 pins = 3 spaces */
  const leftPinGaps = ph - 1

  /** gap size (pitch) */
  const gs = p

  const h = gs * leftPinGaps

  if (isLeft) {
    // The y position starts at h/2, then goes down by gap size
    // for each pin
    // Adding x padding (0.4) to postion the hole in the center
    return { x: -w / 2 - 0.4, y: h / 2 - (pn - 1) * gs }
  }
  // The y position starts at -h/2, then goes up by gap size
  // Adding x padding (0.4) to postion the hole in the center
  return { x: w / 2 + 0.4, y: -h / 2 + (pn - ph - 1) * gs }
}

/**
 * Returns the plated holes for a DIP package.
 */
export const dip = (raw_params: {
  dip: true
  num_pins: number
  w: number
  p?: number
  id?: string | number
  od?: string | number
}): { circuitJson: AnyCircuitElement[]; parameters: any } => {
  const parameters = dip_def.parse(raw_params)
  const platedHoles: AnyCircuitElement[] = []
  for (let i = 0; i < parameters.num_pins; i++) {
    const { x, y } = getCcwDipCoords(
      parameters.num_pins,
      i + 1,
      parameters.w,
      parameters.p ?? 2.54,
    )
    platedHoles.push(
      platedhole(i + 1, x, y, parameters.id ?? "0.8mm", parameters.od ?? "1mm"),
    )
  }
  /** silkscreen width */
  const sw = parameters.w - parameters.od - 0.4
  const sh = (parameters.num_pins / 2 - 1) * parameters.p + parameters.od + 0.4
  const silkscreenBorder: PcbSilkscreenPath = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    route: [
      { x: -sw / 2, y: -sh / 2 },
      { x: -sw / 2, y: sh / 2 },
      // Little U shape at the top
      ...u_curve.map(({ x, y }) => ({
        x: (x * sw) / 6,
        y: (y * sw) / 6 + sh / 2,
      })),
      { x: sw / 2, y: sh / 2 },
      { x: sw / 2, y: -sh / 2 },
      { x: -sw / 2, y: -sh / 2 },
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1,
  }
  const silkscreenPins: PcbFabricationNoteText[] = []
  for (let i = 0; i < parameters.num_pins; i++) {
    const isLeft = i < parameters.num_pins / 2
    const pinLabelX = isLeft
      ? -parameters.w / 2 - parameters.p / 2 - 0.2
      : parameters.p / 2 + parameters.w / 2 + 0.2
    const pinLabelY = isLeft
      ? (-sh + 1.6) / 2 + i * parameters.p
      : (-sh + 1.6) / 2 + (i - parameters.num_pins / 2) * parameters.p
    const silkscreenPin = {
      type: "pcb_fabrication_note_text",
      layer: "top",
      pcb_component_id: `pin_${i + 1}`,
      pcb_silkscreen_text_id: `pin_${i + 1}`,
      text: `{pin${i + 1}}`,
      anchor_position: {
        x: pinLabelX,
        y: pinLabelY,
      },
      font_size: 0.3,
      font_color: "red",
      font: "tscircuit2024",
      anchor_alignment: "top-left",
    }

    silkscreenPins.push(silkscreenPin)
  }
  const silkscreenRefText: SilkscreenRef = silkscreenRef(0, sh / 2 + 0.5, 0.4)

  return {
    circuitJson: [
      ...platedHoles,
      silkscreenBorder,
      silkscreenRefText,
      ...silkscreenPins,
    ],
    parameters,
  }
}

================
File: src/fn/hc49.ts
================
import {
  length,
  type AnySoupElement,
  type PcbSilkscreenPath,
} from "circuit-json"
import { z } from "zod"
import { platedhole } from "src/helpers/platedhole"
import { silkscreenRef, type SilkscreenRef } from "../helpers/silkscreenRef"

const generate_u_curve = (
  centerX: number,
  centerY: number,
  radius: number,
  direction: "left" | "right",
) => {
  return Array.from({ length: 25 }, (_, i) => {
    const theta = (i / 24) * Math.PI - Math.PI / 2
    return {
      x: centerX + (direction === "right" ? 1 : -1) * Math.cos(theta) * radius,
      y: centerY + Math.sin(theta) * radius,
    }
  })
}

export const hc49_def = z.object({
  fn: z.string(),
  p: length.optional().default("4.88mm"),
  id: length.optional().default("0.6mm"),
  od: length.optional().default("1.2mm"),
  w: length.optional().default("5.6mm"),
  h: length.optional().default("3.5mm"),
})

export type Hc49Def = z.input<typeof hc49_def>

export const hc49 = (
  raw_params: Hc49Def,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = hc49_def.parse(raw_params)

  const { p, id, od, w, h } = parameters
  const radius = h / 2

  const plated_holes = [
    platedhole(1, -p / 2, 0, id, od),
    platedhole(2, p / 2, 0, id, od),
  ]

  const leftCurve = generate_u_curve(-w / 2, 0, radius, "left")
  const rightCurve = generate_u_curve(w / 2, 0, radius, "right")

  const silkscreenBody: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      ...leftCurve,
      ...leftCurve.slice(1).reverse(),
      { x: -w / 2, y: -h / 2 },
      { x: w / 2, y: -h / 2 },
      ...rightCurve,
      { x: w / 2, y: h / 2 },
      { x: -w / 2, y: h / 2 },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  const silkscreenRefText: SilkscreenRef = silkscreenRef(0, p / 4, 0.5)

  return {
    circuitJson: [
      ...plated_holes,
      silkscreenBody,
      silkscreenRefText as AnySoupElement,
    ],
    parameters,
  }
}

================
File: src/fn/index.ts
================
export { dip } from "./dip"
export { diode } from "./diode"
export { cap } from "./cap"
export { led } from "./led"
export { res } from "./res"
export { bga } from "./bga"
export { soic } from "./soic"
export { quad } from "./quad"
export { qfn } from "./qfn"
export { qfp } from "./qfp"
export { mlp } from "./mlp"
export { ssop } from "./ssop"
export { tssop } from "./tssop"
export { sot363 } from "./sot363"
export { sot23 } from "./sot23"
export { dfn } from "./dfn"
export { pinrow } from "./pinrow"
export { sot563 } from "./sot563"
export { ms012 } from "./ms012"
export { ms013 } from "./ms013"
export { sot723 } from "./sot723"
export { sod123 } from "./sod123"
export { axial } from "./axial"
export { pushbutton } from "./pushbutton"
export { stampboard } from "./stampboard"
export { stampreceiver } from "./stampreceiver"
export { lqfp } from "./lqfp"
export { breakoutheaders } from "./breakoutheaders"
export { hc49 } from "./hc49"
export { pad } from "./pad"
export { to92 } from "./to92"
export { sod523 } from "./sod523"
export { sop8 } from "./sop8"
export { sod123w } from "./sod123w"
export { sod323 } from "./sod323"
export { sod923 } from "./sod923"
export { sod882 } from "./sod882"
export { sod323f } from "./sod323f"
export { sod123f } from "./sod123f"
export { sod723 } from "./sod723"
export { sod128 } from "./sod128"
export { sot89 } from "./sot89"
export { to220 } from "./to220"
export { minimelf } from "./minimelf"
export { sod882d } from "./sod882d"
export { melf } from "./melf"
export { micromelf } from "./micromelf"
export { sma } from "./sma"
export { smf } from "./smf"
export { smb } from "./smb"
export { vssop8 } from "./vssop8"
export { smc } from "./smc"
export { sot223 } from "./sot223"
export { sod110 } from "./sod110"

================
File: src/fn/led.ts
================
import type { AnySoupElement } from "circuit-json"
import { type PassiveDef, passive } from "../helpers/passive-fn"

export const led = (
  parameters: PassiveDef,
): { circuitJson: AnySoupElement[]; parameters: PassiveDef } => {
  return { circuitJson: passive(parameters), parameters }
}

================
File: src/fn/lqfp.ts
================
import type { AnyCircuitElement } from "circuit-json"
import { quad, quad_def } from "./quad"
import type { z } from "zod"

export const lqfp_def = quad_def

export const lqfp = (
  parameters: z.input<typeof lqfp_def>,
): { circuitJson: AnyCircuitElement[]; parameters: any } => {
  parameters.legsoutside = true
  return quad(parameters)
}

================
File: src/fn/melf.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const melf_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("7.0mm"),
  h: z.string().default("3.35mm"),
  pl: z.string().default("1.50mm"),
  pw: z.string().default("2.70mm"),
  p: z.string().default("4.8mm"),
})

export const melf = (
  raw_params: z.input<typeof melf_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = melf_def.parse(raw_params)

  // Define silkscreen reference text
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h),
    0.3,
  )

  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length.parse(parameters.p) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2,
        y: -length.parse(parameters.h) / 2,
      },
      {
        x: length.parse(parameters.p) / 2,
        y: -length.parse(parameters.h) / 2,
      },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  return {
    circuitJson: melfWithoutParsing(parameters).concat(
      silkscreenLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

export const getMelfCoords = (parameters: {
  pn: number
  p: number
}) => {
  const { pn, p } = parameters

  if (pn === 1) {
    return { x: -p / 2, y: 0 }
    // biome-ignore lint/style/noUselessElse: <explanation>
  } else {
    return { x: p / 2, y: 0 }
  }
}

export const melfWithoutParsing = (parameters: z.infer<typeof melf_def>) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getMelfCoords({
      pn: i,
      p: Number.parseFloat(parameters.p),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/micromelf.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const micromelf_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("3.0mm"),
  h: z.string().default("1.80mm"),
  pl: z.string().default("0.80mm"),
  pw: z.string().default("1.20mm"),
  p: z.string().default("1.6mm"),
})

export const micromelf = (
  raw_params: z.input<typeof micromelf_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = micromelf_def.parse(raw_params)

  // Define silkscreen reference text
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h),
    0.3,
  )

  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length.parse(parameters.p) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.1,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.1,
        y: -length.parse(parameters.h) / 2,
      },
      {
        x: length.parse(parameters.p) / 2,
        y: -length.parse(parameters.h) / 2,
      },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  return {
    circuitJson: microMelfWithoutParsing(parameters).concat(
      silkscreenLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

export const getMicroMelfCoords = (parameters: {
  pn: number
  p: number
}) => {
  const { pn, p } = parameters

  if (pn === 1) {
    return { x: -p / 2, y: 0 }
    // biome-ignore lint/style/noUselessElse: <explanation>
  } else {
    return { x: p / 2, y: 0 }
  }
}

export const microMelfWithoutParsing = (
  parameters: z.infer<typeof micromelf_def>,
) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getMicroMelfCoords({
      pn: i,
      p: Number.parseFloat(parameters.p),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/minimelf.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const minimelf_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("5.40mm"),
  h: z.string().default("2.30mm"),
  pl: z.string().default("1.30mm"),
  pw: z.string().default("1.70mm"),
  p: z.string().default("3.5mm"),
})

export const minimelf = (
  raw_params: z.input<typeof minimelf_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = minimelf_def.parse(raw_params)

  // Define silkscreen reference text
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h) / 2 + 0.4,
    0.3,
  )

  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length.parse(parameters.p) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2,
        y: -length.parse(parameters.h) / 2,
      },
      {
        x: length.parse(parameters.p) / 2,
        y: -length.parse(parameters.h) / 2,
      },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  return {
    circuitJson: miniMelfWithoutParsing(parameters).concat(
      silkscreenLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

export const getMiniMelfCoords = (parameters: {
  pn: number
  p: number
}) => {
  const { pn, p } = parameters

  return pn === 1 ? { x: -p / 2, y: 0 } : { x: p / 2, y: 0 }
}

export const miniMelfWithoutParsing = (
  parameters: z.infer<typeof minimelf_def>,
) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getMiniMelfCoords({
      pn: i,
      p: Number.parseFloat(parameters.p),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/mlp.ts
================
import type { AnySoupElement } from "circuit-json"
import { base_quad_def, quad, quad_def, quadTransform } from "./quad"
import type { z } from "zod"

export const mlp_def = base_quad_def.extend({}).transform(quadTransform)

export const mlp = (
  parameters: z.input<typeof mlp_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  parameters.legsoutside = false
  if (parameters.thermalpad === undefined) {
    parameters.thermalpad = true
  }
  return quad(parameters)
}

================
File: src/fn/ms012.ts
================
import type { AnyCircuitElement } from "circuit-json"
import { extendSoicDef, soicWithoutParsing } from "./soic"
import type { z } from "zod"

export const ms012_def = extendSoicDef({
  p: "1.27mm",
  w: "3.9mm",
  legsoutside: true,
})

export const ms012 = (
  raw_params: z.input<typeof ms012_def>,
): { circuitJson: AnyCircuitElement[]; parameters: any } => {
  const parameters = ms012_def.parse({ ...raw_params, num_pins: 8 })
  return {
    circuitJson: soicWithoutParsing(parameters),
    parameters,
  }
}

================
File: src/fn/ms013.ts
================
import type { AnySoupElement } from "circuit-json"
import { extendSoicDef, soicWithoutParsing } from "./soic"
import type { z } from "zod"

export const ms013_def = extendSoicDef({
  p: "1.27mm",
  w: "7.5mm",
  legsoutside: true,
})

export const ms013 = (
  raw_params: z.input<typeof ms013_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = ms013_def.parse({ ...raw_params, num_pins: 16 })
  return {
    circuitJson: soicWithoutParsing(parameters),
    parameters,
  }
}

================
File: src/fn/pad.ts
================
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef } from "../helpers/silkscreenRef"
import type { AnySoupElement } from "circuit-json"
import { length } from "circuit-json"
import { mm } from "@tscircuit/mm"

export const pad_def = z.object({
  w: length,
  h: length,
})

export type PadDef = z.input<typeof pad_def>

export const pad = (params: PadDef): { circuitJson: AnySoupElement[] } => {
  const { w, h } = params
  const width = mm(w)
  const height = mm(h)

  return {
    circuitJson: [
      rectpad(1, 0, 0, width, height),
      silkscreenRef(0, height / 2 + 0.5, 0.2),
    ],
  }
}

================
File: src/fn/pinrow.ts
================
import { z } from "zod"
import { length, type AnySoupElement } from "circuit-json"
import { platedhole } from "../helpers/platedhole"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"

export const pinrow_def = z
  .object({
    fn: z.string(),
    num_pins: z.number().optional().default(6),
    rows: z
      .union([z.string(), z.number()])
      .transform((val) => Number(val))
      .optional()
      .default(1)
      .describe("number of rows"),
    p: length.default("0.1in").describe("pitch"),
    id: length.default("1.0mm").describe("inner diameter"),
    od: length.default("1.5mm").describe("outer diameter"),
    male: z.boolean().optional().describe("for male pin headers"),
    female: z.boolean().optional().describe("for female pin headers"),
  })
  .transform((data) => ({
    ...data,
    male: data.male ?? (data.female ? false : true),
    female: data.female ?? false,
  }))
  .superRefine((data, ctx) => {
    if (data.male && data.female) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message:
          "'male' and 'female' cannot both be true; it should be male or female.",
        path: ["male", "female"],
      })
    }
  })

export const pinrow = (
  raw_params: z.input<typeof pinrow_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = pinrow_def.parse(raw_params)
  const { p, id, od, rows } = parameters

  const holes: any[] = []
  const num_pins = parameters.num_pins

  if (rows > 1) {
    const num_pins_per_row = Math.ceil(num_pins / rows)
    const ySpacing = p

    for (let row = 0; row < rows; row++) {
      const yoff = row * ySpacing
      const startPin = row * num_pins_per_row

      for (let pinIndex = 0; pinIndex < num_pins_per_row; pinIndex++) {
        const pinNumber = startPin + pinIndex + 1
        if (pinNumber > num_pins) break

        const xoff = pinIndex * p
        holes.push(platedhole(pinNumber, xoff, yoff, id, od))
      }
    }
  } else {
    const num_spaces = num_pins - 1
    const xoff = -(num_spaces / 2) * p
    for (let i = 0; i < num_pins; i++) {
      holes.push(platedhole(i + 1, xoff + i * p, 0, id, od))
    }
  }

  if (rows === 1) {
    const silkscreenRefText: SilkscreenRef = silkscreenRef(0, rows * p, 0.5)
    return {
      circuitJson: [...holes, silkscreenRefText] as AnySoupElement[],
      parameters,
    }
  }
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    ((num_pins / rows - 1) * p) / 2, // Center the silkscreen horizontally
    rows * p, // Keep it at the top vertically
    0.5,
  )
  return {
    circuitJson: [...holes, silkscreenRefText] as AnySoupElement[],
    parameters,
  }
}

================
File: src/fn/pushbutton.ts
================
import { length, type AnyCircuitElement } from "circuit-json"
import { z } from "zod"
import { platedhole } from "../helpers/platedhole"
import { silkscreenpath } from "../helpers/silkscreenpath"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"

export const pushbutton_def = z.object({
  fn: z.literal("pushbutton"),
  w: length.default(4.5),
  h: length.default(6.5),
  id: length.default(1),
  od: length.default(1.2),
})

export const pushbutton = (
  raw_params: z.input<typeof pushbutton_def>,
): { circuitJson: AnyCircuitElement[]; parameters: any } => {
  const parameters = pushbutton_def.parse(raw_params)

  const width = parameters.w
  const height = parameters.h
  const holeDiameter = parameters.id

  const holes: AnyCircuitElement[] = [
    platedhole(1, -width / 2, height / 2, holeDiameter, holeDiameter * 1.5),
    platedhole(2, -width / 2, -height / 2, holeDiameter, holeDiameter * 1.5),
    platedhole(3, width / 2, -height / 2, holeDiameter, holeDiameter * 1.5),
    platedhole(4, width / 2, height / 2, holeDiameter, holeDiameter * 1.5),
  ]

  const silkscreenLines: AnyCircuitElement[] = [
    // Vertical lines indicating connections
    silkscreenpath([
      { x: -width / 2, y: -height / 2 },
      { x: -width / 2, y: height / 2 },
    ]),
    silkscreenpath([
      { x: width / 2, y: -height / 2 },
      { x: width / 2, y: height / 2 },
    ]),
    // Center indicating latch
    silkscreenpath([
      { x: -width / 2, y: 0 },
      { x: -width / 5, y: 0 },
      { x: ((width / 5) * 1) / Math.sqrt(2), y: height / 8 },
    ]),
    silkscreenpath([
      { x: width / 2, y: 0 },
      { x: width / 5, y: 0 },
    ]),
  ]
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    height / 2 + 0.4,
    0.5,
  )
  return {
    circuitJson: [...holes, ...silkscreenLines, silkscreenRefText],
    parameters,
  }
}

================
File: src/fn/qfn.ts
================
import type { AnySoupElement } from "circuit-json"
import { base_quad_def, quad, quad_def, quadTransform } from "./quad"
import type { z } from "zod"

export const qfn_def = base_quad_def.extend({}).transform(quadTransform)

export const qfn = (
  parameters: z.input<typeof qfn_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  parameters.legsoutside = false
  return quad(parameters)
}

================
File: src/fn/qfp.ts
================
import type { AnyCircuitElement } from "circuit-json"
import { quad, quad_def } from "./quad"
import type { z } from "zod"

export const qfp_def = quad_def

export const qfp = (
  raw_params: z.input<typeof quad_def>,
): { circuitJson: AnyCircuitElement[]; parameters: any } => {
  raw_params.legsoutside = true

  const quad_defaults = quad_def.parse(raw_params)
  if (!raw_params.p) {
    switch (raw_params.num_pins) {
      case 44:
      case 64:
        raw_params.p = 0.8
        break
      case 52:
        if (raw_params.w === 14) raw_params.p = 1
        else raw_params.p = 0.65
        break
      case 208:
        raw_params.p = 0.5
        break
    }
  }
  if (!raw_params.pl) {
    switch (raw_params.num_pins) {
      case 44:
      case 52:
      case 64:
        raw_params.pl = 2.25
        break
      case 208:
        raw_params.pl = 1.65
        break
      default:
        raw_params.pl = quad_defaults.pl * 4
        break
    }
  }
  if (!raw_params.pw) {
    switch (raw_params.num_pins) {
      case 44:
      case 64:
        raw_params.pw = 0.5
        break
      case 52:
        if (raw_params.w === 14) raw_params.pw = 0.45
        else raw_params.pw = 0.55
        break
      case 208:
        raw_params.pw = 0.3
        break
      default:
        raw_params.pw = quad_defaults.pw
        break
    }
  }
  return quad(raw_params)
}

================
File: src/fn/quad.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { optional, z } from "zod"
import { length } from "circuit-json"
import type { NowDefined } from "../helpers/zod/now-defined"
import { rectpad } from "../helpers/rectpad"
import { pin_order_specifier } from "src/helpers/zod/pin-order-specifier"
import { getQuadPinMap } from "src/helpers/get-quad-pin-map"
import { dim2d } from "src/helpers/zod/dim-2d"
import { type SilkscreenRef, silkscreenRef } from "src/helpers/silkscreenRef"

export const base_quad_def = z.object({
  fn: z.string(),
  cc: z.boolean().default(true).optional(),
  ccw: z.boolean().default(true).optional(),
  startingpin: z
    .string()
    .or(z.array(pin_order_specifier))
    .transform((a) => (typeof a === "string" ? a.slice(1, -1).split(",") : a))
    .pipe(z.array(pin_order_specifier))
    .optional(),
  num_pins: z.number().optional().default(64),
  w: length.optional(),
  h: length.optional(),
  p: length.default(length.parse("0.5mm")),
  pw: length.optional(),
  pl: length.optional(),
  thermalpad: z.union([z.literal(true), dim2d]).optional(),
  legsoutside: z.boolean().default(false),
})

export const quadTransform = <T extends z.infer<typeof base_quad_def>>(
  v: T,
) => {
  if (v.w && !v.h) {
    v.h = v.w
  } else if (!v.w && v.h) {
    v.w = v.h
  }

  const side_pin_count = v.num_pins / 4

  if (!v.p && !v.pw && !v.pl && v.w) {
    // HACK: This is wayyy underspecified
    const approx_pin_size_of_side = side_pin_count + 4
    v.p = v.w / approx_pin_size_of_side
  }

  if (!v.p && v.w && v.h && v.pw && v.pl) {
    // HACK: This is wayyy underspecified
    v.p = (v.w - v.pl * 2) / (side_pin_count - 1)
  }

  if (!v.w && !v.h && v.p) {
    // HACK: underspecified
    v.w = v.p * (side_pin_count + 4)
    v.h = v.w
  }

  if (v.p && !v.pw && !v.pl) {
    v.pw = v.p / 2
    v.pl = v.p / 2
  } else if (!v.pw) {
    v.pw = v.pl! * (0.6 / 1.0)
  } else if (!v.pl) {
    v.pl = v.pw! * (1.0 / 0.6)
  }

  return v as NowDefined<T, "w" | "h" | "p" | "pw" | "pl">
}

export const quad_def = base_quad_def.transform(quadTransform)

const SIDES_CCW = ["left", "bottom", "right", "top"] as const

export const getQuadCoords = (params: {
  pin_count: number
  pn: number // pin number
  w: number // width of the package
  h: number // height (length) of the package
  p: number // pitch between pins
  pl: number // length of the pin
  legsoutside?: boolean
}) => {
  const { pin_count, pn, w, h, p, pl, legsoutside } = params
  const sidePinCount = pin_count / 4
  const side = SIDES_CCW[Math.floor((pn - 1) / sidePinCount)]
  const pos = (pn - 1) % sidePinCount

  /** inner box width */
  const ibw = p * (sidePinCount - 1)
  /** inner box height */
  const ibh = p * (sidePinCount - 1)

  /** pad center distance from edge (negative is inside, positive is outside) */
  const pcdfe = legsoutside ? pl / 2 : -pl / 2

  switch (side) {
    case "left":
      return { x: -w / 2 - pcdfe, y: ibh / 2 - pos * p, o: "vert" }
    case "bottom":
      return { x: -ibw / 2 + pos * p, y: -h / 2 - pcdfe, o: "horz" }
    case "right":
      return { x: w / 2 + pcdfe, y: -ibh / 2 + pos * p, o: "vert" }
    case "top":
      return { x: ibw / 2 - pos * p, y: h / 2 + pcdfe, o: "horz" }
    default:
      throw new Error("Invalid pin number")
  }
}

export const quad = (
  raw_params: z.input<typeof quad_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = quad_def.parse(raw_params)
  const pads: AnySoupElement[] = []
  const pin_map = getQuadPinMap(parameters)
  /** Side pin count */
  const spc = parameters.num_pins / 4
  for (let i = 0; i < parameters.num_pins; i++) {
    const {
      x,
      y,
      o: orientation,
    } = getQuadCoords({
      pin_count: parameters.num_pins,
      pn: i + 1,
      w: parameters.w,
      h: parameters.h,
      p: parameters.p ?? 0.5,
      pl: parameters.pl,
      legsoutside: parameters.legsoutside,
    })

    let pw = parameters.pw
    let pl = parameters.pl
    if (orientation === "vert") {
      ;[pw, pl] = [pl, pw]
    }

    const pn = pin_map[i + 1]!
    pads.push(rectpad(pn, x, y, pw, pl))
  }

  if (parameters.thermalpad) {
    if (typeof parameters.thermalpad === "boolean") {
      const ibw = parameters.p * (spc - 1) + parameters.pw
      const ibh = parameters.p * (spc - 1) + parameters.pw
      pads.push(rectpad(["thermalpad"], 0, 0, ibw, ibh))
    } else {
      pads.push(
        rectpad(
          ["thermalpad"],
          0,
          0,
          parameters.thermalpad.x,
          parameters.thermalpad.y,
        ),
      )
    }
  }

  // Silkscreen corners
  const silkscreen_corners: PcbSilkscreenPath[] = []
  for (const [corner, dx, dy] of [
    ["top-left", -1, 1],
    ["bottom-left", -1, -1],
    ["bottom-right", 1, -1],
    ["top-right", 1, 1],
  ] as const) {
    // const dx = Math.floor(corner_index / 2) * 2 - 1
    // const dy = 1 - (corner_index % 2) * 2
    const corner_x = (parameters.w / 2) * dx
    const corner_y = (parameters.h / 2) * dy
    let arrow: "none" | "in1" | "in2" = "none"

    let arrow_x = corner_x
    let arrow_y = corner_y

    /** corner size */
    const csz = parameters.pw * 2

    if (pin_map[1] === 1 && corner === "top-left") {
      arrow = "in1"
    } else if (pin_map[spc * 4] === 1 && corner === "top-left") {
      arrow = "in2"
    } else if (pin_map[spc * 3 + 1] === 1 && corner === "top-right") {
      arrow = "in2"
    } else if (pin_map[spc * 3] === 1 && corner === "top-right") {
      arrow = "in1"
    } else if (pin_map[spc] === 1 && corner === "bottom-left") {
      arrow = "in1"
    } else if (pin_map[spc + 1] === 1 && corner === "bottom-left") {
      arrow = "in2"
    } else if (pin_map[spc * 2] === 1 && corner === "bottom-right") {
      arrow = "in1"
    } else if (pin_map[spc * 2 + 1] === 1 && corner === "bottom-right") {
      arrow = "in2"
    }

    const rotate_arrow = arrow === "in1" ? 1 : -1
    if (parameters.legsoutside) {
      const arrow_dx = arrow === "in1" ? parameters.pl / 2 : parameters.pw / 2
      const arrow_dy = arrow === "in1" ? parameters.pw / 2 : parameters.pl / 2
      arrow_x += arrow_dx * dx * rotate_arrow
      arrow_y -= arrow_dy * dy * rotate_arrow
    }

    // Normal Corner
    if (arrow === "none" || parameters.legsoutside) {
      silkscreen_corners.push({
        layer: "top",
        pcb_component_id: "",
        pcb_silkscreen_path_id: `pcb_silkscreen_path_${corner}`,
        route: [
          {
            x: corner_x - csz * dx,
            y: corner_y,
          },
          {
            x: corner_x,
            y: corner_y,
          },
          {
            x: corner_x,
            y: corner_y - csz * dy,
          },
        ],
        type: "pcb_silkscreen_path",
        stroke_width: 0.1,
      })
    }

    // Two lines nearly forming a corner, used when the arrow needs to overlap
    // the corne (QFN components where legs are inside)
    if ((arrow === "in1" || arrow === "in2") && !parameters.legsoutside) {
      silkscreen_corners.push(
        {
          layer: "top",
          pcb_component_id: "",
          pcb_silkscreen_path_id: `pcb_silkscreen_path_${corner}_1`,
          route: [
            {
              x: corner_x - csz * dx,
              y: corner_y,
            },
            {
              x: corner_x - (csz * dx) / 2,
              y: corner_y,
            },
          ],
          type: "pcb_silkscreen_path",
          stroke_width: 0,
        },
        {
          layer: "top",
          pcb_component_id: "",
          pcb_silkscreen_path_id: `pcb_silkscreen_path_${corner}_2`,
          route: [
            {
              x: corner_x,
              y: corner_y - (csz * dy) / 2,
            },
            {
              x: corner_x,
              y: corner_y - csz * dy,
            },
          ],
          type: "pcb_silkscreen_path",
          stroke_width: 0.1,
        },
      )
    }
    if (arrow === "in1" || arrow === "in2") {
      silkscreen_corners.push({
        layer: "top",
        pcb_component_id: "",
        pcb_silkscreen_path_id: `pcb_silkscreen_path_${corner}_3`,
        route: [
          {
            x: arrow_x - 0.2 * -dx,
            y: arrow_y + 0.2 * rotate_arrow,
          },
          {
            x: arrow_x,
            y: arrow_y,
          },
          {
            x: arrow_x + 0.2 * rotate_arrow * -dx,
            y: arrow_y + 0.2,
          },
          {
            x: arrow_x - 0.2 * -dx,
            y: arrow_y + 0.2 * rotate_arrow,
          },
        ],
        type: "pcb_silkscreen_path",
        stroke_width: 0.1,
      })
    }
  }
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    parameters.h / 2 + (parameters.legsoutside ? parameters.pl * 1.2 : 0.5),
    0.3,
  )
  return {
    circuitJson: [
      ...pads,
      ...silkscreen_corners,
      silkscreenRefText,
    ] as AnySoupElement[],
    parameters,
  }
}

================
File: src/fn/res.ts
================
import type { AnySoupElement } from "circuit-json"
import { passive, type PassiveDef } from "../helpers/passive-fn"

export const res = (
  parameters: PassiveDef,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  return { circuitJson: passive(parameters), parameters }
}

================
File: src/fn/sma.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const sma_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("7.10mm"),
  h: z.string().default("3.40mm"),
  pl: z.string().default("2.45mm"),
  pw: z.string().default("1.80mm"),
  p: z.string().default("4.05mm"),
})

export const sma = (
  raw_params: z.input<typeof sma_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = sma_def.parse(raw_params)

  // Define silkscreen reference text
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h) / 2 + 0.5,
    0.3,
  )

  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length.parse(parameters.p) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.5,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.5,
        y: -length.parse(parameters.h) / 2,
      },
      {
        x: length.parse(parameters.p) / 2,
        y: -length.parse(parameters.h) / 2,
      },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  return {
    circuitJson: smaWithoutParsing(parameters).concat(
      silkscreenLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

// Get coordinates for sma pads
export const getSmaCoords = (parameters: {
  pn: number
  p: number
}) => {
  const { pn, p } = parameters

  if (pn === 1) {
    return { x: -p / 2, y: 0 }
  }
  return { x: p / 2, y: 0 }
}

// Function to generate sma pads
export const smaWithoutParsing = (parameters: z.infer<typeof sma_def>) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSmaCoords({
      pn: i,
      p: Number.parseFloat(parameters.p),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/smb.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const smb_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("7.30mm"),
  h: z.string().default("4.40mm"),
  pl: z.string().default("2.50mm"),
  pw: z.string().default("2.30mm"),
  p: z.string().default("4.30mm"),
})

export const smb = (
  raw_params: z.input<typeof smb_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = smb_def.parse(raw_params)

  // Define silkscreen reference text
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h) / 2 + 0.5,
    0.3,
  )

  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length.parse(parameters.p) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.1,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.1,
        y: -length.parse(parameters.h) / 2,
      },
      {
        x: length.parse(parameters.p) / 2,
        y: -length.parse(parameters.h) / 2,
      },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  return {
    circuitJson: smbWithoutParsing(parameters).concat(
      silkscreenLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

// Get coordinates for smb pads
export const getSmbCoords = (parameters: {
  pn: number
  p: number
}) => {
  const { pn, p } = parameters

  if (pn === 1) {
    return { x: -p / 2, y: 0 }
    // biome-ignore lint/style/noUselessElse: <explanation>
  } else {
    return { x: p / 2, y: 0 }
  }
}

// Function to generate smb pads
export const smbWithoutParsing = (parameters: z.infer<typeof smb_def>) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSmbCoords({
      pn: i,
      p: Number.parseFloat(parameters.p),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/smc.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const smc_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("10.70mm"),
  h: z.string().default("6.60mm"),
  pl: z.string().default("3.30mm"),
  pw: z.string().default("2.50mm"),
  p: z.string().default("6.80mm"),
})

export const smc = (
  raw_params: z.input<typeof smc_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = smc_def.parse(raw_params)

  // Define silkscreen reference text
  const silkscreenRefText: SilkscreenRef = silkscreenRef(0, 3, 0.3)

  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length.parse(parameters.p) / 2,
        y: length.parse(parameters.h) / 2 - 0.8,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.8,
        y: length.parse(parameters.h) / 2 - 0.8,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.8,
        y: -length.parse(parameters.h) / 2 + 0.8,
      },
      {
        x: length.parse(parameters.p) / 2,
        y: -length.parse(parameters.h) / 2 + 0.8,
      },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  return {
    circuitJson: smcWithoutParsing(parameters).concat(
      silkscreenLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

// Get coordinates for smc pads
export const getSmcCoords = (parameters: {
  pn: number
  p: number
}) => {
  const { pn, p } = parameters

  if (pn === 1) {
    return { x: -p / 2, y: 0 }
  }
  return { x: p / 2, y: 0 }
}

// Function to generate smc pads
export const smcWithoutParsing = (parameters: z.infer<typeof smc_def>) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSmcCoords({
      pn: i,
      p: Number.parseFloat(parameters.p),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/smf.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const smf_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("4.80mm"),
  h: z.string().default("2.10mm"),
  pl: z.string().default("1.30mm"),
  pw: z.string().default("1.40mm"),
  p: z.string().default("2.9mm"),
})

export const smf = (
  raw_params: z.input<typeof smf_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = smf_def.parse(raw_params)

  // Define silkscreen reference text
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h) - 0.5,
    0.3,
  )

  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length.parse(parameters.p) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2,
        y: -length.parse(parameters.h) / 2,
      },
      {
        x: length.parse(parameters.p) / 2,
        y: -length.parse(parameters.h) / 2,
      },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  return {
    circuitJson: smfWithoutParsing(parameters).concat(
      silkscreenLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

// Get coordinates for smf pads
export const getSmfCoords = (parameters: {
  pn: number
  p: number
}) => {
  const { pn, p } = parameters

  if (pn === 1) {
    return { x: -p / 2, y: 0 }
    // biome-ignore lint/style/noUselessElse: <explanation>
  } else {
    return { x: p / 2, y: 0 }
  }
}

// Function to generate smf pads
export const smfWithoutParsing = (parameters: z.infer<typeof smf_def>) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSmfCoords({
      pn: i,
      p: Number.parseFloat(parameters.p),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/sod110.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const sod_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("3.30mm"),
  h: z.string().default("1.70mm"),
  pl: z.string().default("0.80mm"),
  pw: z.string().default("1mm"),
  p: z.string().default("1.90mm"),
})

export const sod110 = (
  raw_params: z.input<typeof sod_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = sod_def.parse(raw_params)
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h) / 2 + 0.5,
    0.3,
  )

  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length.parse(parameters.p) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2,
        y: -length.parse(parameters.h) / 2,
      },
      {
        x: length.parse(parameters.p) / 2,
        y: -length.parse(parameters.h) / 2,
      },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  return {
    circuitJson: sodWithoutParsing(parameters).concat(
      silkscreenLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

export const getSodCoords = (parameters: {
  pn: number
  p: number
}) => {
  const { pn, p } = parameters

  if (pn === 1) {
    return { x: -p / 2, y: 0 }
  }

  return { x: p / 2, y: 0 }
}

export const sodWithoutParsing = (parameters: z.infer<typeof sod_def>) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords({
      pn: i,
      p: Number.parseFloat(parameters.p),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/sod123.ts
================
import type { AnySoupElement } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const sod_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("2.36mm"),
  h: z.string().default("1.22mm"),
  pl: z.string().default("0.9mm"),
  pw: z.string().default("0.9mm"),
  p: z.string().default("4.19mm"),
})

export const sod123 = (
  raw_params: z.input<typeof sod_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = sod_def.parse(raw_params)
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h) / 4 + 0.4,
    0.3,
  )

  return {
    circuitJson: sodWithoutParsing(parameters).concat(
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

export const getSodCoords = (parameters: {
  pn: number
  p: number
}) => {
  const { pn, p } = parameters

  if (pn === 1) {
    return { x: -p / 2, y: 0 }
    // biome-ignore lint/style/noUselessElse: <explanation>
  } else {
    return { x: p / 2, y: 0 }
  }
}

export const sodWithoutParsing = (parameters: z.infer<typeof sod_def>) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords({
      pn: i,
      p: Number.parseFloat(parameters.p),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/sod123f.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const sod_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("4.4mm"),
  h: z.string().default("2.1mm"),
  pl: z.string().default("1.2mm"),
  pw: z.string().default("1.2mm"),
  p: z.string().default("2.9mm"),
})

export const sod123f = (
  raw_params: z.input<typeof sod_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = sod_def.parse(raw_params)

  // Define silkscreen reference text
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h),
    0.3,
  )

  // Define silkscreen path that goes till half of the second pad
  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length.parse(parameters.p) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.2,
        y: -length.parse(parameters.h) / 2,
      },
      {
        x: length.parse(parameters.p) / 2,
        y: -length.parse(parameters.h) / 2,
      },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  return {
    circuitJson: sodWithoutParsing(parameters).concat(
      silkscreenLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

// Get coordinates for SOD pads
export const getSodCoords = (parameters: {
  pn: number
  p: number
}) => {
  const { pn, p } = parameters

  if (pn === 1) {
    return { x: -p / 2, y: 0 }
    // biome-ignore lint/style/noUselessElse: <explanation>
  } else {
    return { x: p / 2, y: 0 }
  }
}

// Function to generate SOD pads
export const sodWithoutParsing = (parameters: z.infer<typeof sod_def>) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords({
      pn: i,
      p: Number.parseFloat(parameters.p),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/sod123w.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const sod_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("4.4mm"),
  h: z.string().default("2.1mm"),
  pl: z.string().default("1.2mm"),
  pw: z.string().default("1.2mm"),
  p: z.string().default("2.9mm"),
})

export const sod123w = (
  raw_params: z.input<typeof sod_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = sod_def.parse(raw_params)

  // Define silkscreen reference text
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h) - 0.5,
    0.3,
  )

  // Define silkscreen path that goes till half of the second pad
  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length.parse(parameters.p) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.2,
        y: -length.parse(parameters.h) / 2,
      },
      {
        x: length.parse(parameters.p) / 2,
        y: -length.parse(parameters.h) / 2,
      },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  return {
    circuitJson: sodWithoutParsing(parameters).concat(
      silkscreenLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

// Get coordinates for SOD pads
export const getSodCoords = (parameters: {
  pn: number
  p: number
}) => {
  const { pn, p } = parameters

  if (pn === 1) {
    return { x: -p / 2, y: 0 }
  }
  return { x: p / 2, y: 0 }
}

// Function to generate SOD pads
export const sodWithoutParsing = (parameters: z.infer<typeof sod_def>) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords({
      pn: i,
      p: Number.parseFloat(parameters.p),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/sod128.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const sod_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("6.2mm"),
  h: z.string().default("3.4mm"),
  pl: z.string().default("1.4mm"),
  pw: z.string().default("2.1mm"),
  p: z.string().default("4.4mm"),
})

export const sod128 = (
  raw_params: z.input<typeof sod_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = sod_def.parse(raw_params)

  // Define silkscreen reference text
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h) / 2 + 0.4,
    0.3,
  )

  // Define silkscreen path that goes till half of the second pad
  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length.parse(parameters.p) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.2,
        y: -length.parse(parameters.h) / 2,
      },
      {
        x: length.parse(parameters.p) / 2,
        y: -length.parse(parameters.h) / 2,
      },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  return {
    circuitJson: sodWithoutParsing(parameters).concat(
      silkscreenLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

// Get coordinates for SOD pads
export const getSodCoords = (parameters: {
  pn: number
  p: number
}) => {
  const { pn, p } = parameters

  if (pn === 1) {
    return { x: -p / 2, y: 0 }
    // biome-ignore lint/style/noUselessElse: <explanation>
  } else {
    return { x: p / 2, y: 0 }
  }
}

// Function to generate SOD pads
export const sodWithoutParsing = (parameters: z.infer<typeof sod_def>) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords({
      pn: i,
      p: Number.parseFloat(parameters.p),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/sod323.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const sod_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("3.30mm"),
  h: z.string().default("1.80mm"),
  pl: z.string().default("0.60mm"),
  pw: z.string().default("0.45mm"),
  p: z.string().default("2.1mm"),
})

export const sod323 = (
  raw_params: z.input<typeof sod_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = sod_def.parse(raw_params)

  // Define silkscreen reference text
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h) - 0.5,
    0.3,
  )

  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length.parse(parameters.p) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2,
        y: -length.parse(parameters.h) / 2,
      },
      {
        x: length.parse(parameters.p) / 2,
        y: -length.parse(parameters.h) / 2,
      },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  return {
    circuitJson: sodWithoutParsing(parameters).concat(
      silkscreenLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

// Get coordinates for SOD pads
export const getSodCoords = (parameters: {
  pn: number
  p: number
}) => {
  const { pn, p } = parameters

  if (pn === 1) {
    return { x: -p / 2, y: 0 }
  }
  return { x: p / 2, y: 0 }
}

// Function to generate SOD pads
export const sodWithoutParsing = (parameters: z.infer<typeof sod_def>) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords({
      pn: i,
      p: Number.parseFloat(parameters.p),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/sod323f.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const sod_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("3,05mm"),
  h: z.string().default("1.65mm"),
  pl: z.string().default("0.6mm"),
  pw: z.string().default("0.6mm"),
  pad_spacing: z.string().default("2.2mm"),
})

export const sod323f = (
  raw_params: z.input<typeof sod_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = sod_def.parse(raw_params)

  // Define silkscreen reference text
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h),
    0.3,
  )

  // Define silkscreen path that goes till half of the second pad
  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length.parse(parameters.pad_spacing) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.2,
        y: -length.parse(parameters.h) / 2,
      },
      {
        x: length.parse(parameters.pad_spacing) / 2,
        y: -length.parse(parameters.h) / 2,
      },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  return {
    circuitJson: sodWithoutParsing(parameters).concat(
      silkscreenLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

// Get coordinates for SOD pads
export const getSodCoords = (parameters: {
  pn: number
  pad_spacing: number
}) => {
  const { pn, pad_spacing } = parameters

  if (pn === 1) {
    return { x: -pad_spacing / 2, y: 0 }
    // biome-ignore lint/style/noUselessElse: <explanation>
  } else {
    return { x: pad_spacing / 2, y: 0 }
  }
}

// Function to generate SOD pads
export const sodWithoutParsing = (parameters: z.infer<typeof sod_def>) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords({
      pn: i,
      pad_spacing: Number.parseFloat(parameters.pad_spacing),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/sod523.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const sod_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("2.15mm"),
  h: z.string().default("1.20mm"),
  pl: z.string().default("0.5mm"),
  pw: z.string().default("0.6mm"),
  p: z.string().default("1.4mm"),
})

export const sod523 = (
  raw_params: z.input<typeof sod_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = sod_def.parse(raw_params)

  // Define silkscreen reference text
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h),
    0.3,
  )

  // Define silkscreen path that goes till half of the second pad
  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length.parse(parameters.p) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.2,
        y: -length.parse(parameters.h) / 2,
      },
      {
        x: length.parse(parameters.p) / 2,
        y: -length.parse(parameters.h) / 2,
      },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  return {
    circuitJson: sodWithoutParsing(parameters).concat(
      silkscreenLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

// Get coordinates for SOD pads
export const getSodCoords = (parameters: {
  pn: number
  p: number
}) => {
  const { pn, p } = parameters

  if (pn === 1) {
    return { x: -p / 2, y: 0 }
    // biome-ignore lint/style/noUselessElse: <explanation>
  } else {
    return { x: p / 2, y: 0 }
  }
}

// Function to generate SOD pads
export const sodWithoutParsing = (parameters: z.infer<typeof sod_def>) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords({
      pn: i,
      p: Number.parseFloat(parameters.p),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/sod723.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const sod_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("1.80mm"),
  h: z.string().default("1.00mm"),
  pl: z.string().default("0.66mm"),
  pw: z.string().default("0.5mm"),
  p: z.string().default("0.8mm"),
})

export const sod723 = (
  raw_params: z.input<typeof sod_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = sod_def.parse(raw_params)

  // Define silkscreen reference text
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h),
    0.3,
  )

  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length.parse(parameters.p) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.1,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.1,
        y: -length.parse(parameters.h) / 2,
      },
      {
        x: length.parse(parameters.p) / 2,
        y: -length.parse(parameters.h) / 2,
      },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  return {
    circuitJson: sodWithoutParsing(parameters).concat(
      silkscreenLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

// Get coordinates for SOD pads
export const getSodCoords = (parameters: {
  pn: number
  p: number
}) => {
  const { pn, p } = parameters

  if (pn === 1) {
    return { x: -p / 2, y: 0 }
    // biome-ignore lint/style/noUselessElse: <explanation>
  } else {
    return { x: p / 2, y: 0 }
  }
}

// Function to generate SOD pads
export const sodWithoutParsing = (parameters: z.infer<typeof sod_def>) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords({
      pn: i,
      p: Number.parseFloat(parameters.p),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/sod882.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const sod_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("1.3mm"),
  h: z.string().default("0.9mm"),
  pl: z.string().default("0.4mm"),
  pw: z.string().default("0.7mm"),
  p: z.string().default("0.7mm"),
})

export const sod882 = (
  raw_params: z.input<typeof sod_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = sod_def.parse(raw_params)

  // Define silkscreen reference text
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h) + 0.1,
    0.3,
  )

  // Define silkscreen path that goes till half of the second pad
  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length.parse(parameters.p) / 2 + 0.2,
        y: length.parse(parameters.h) / 2 + 0.2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.2,
        y: length.parse(parameters.h) / 2 + 0.2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.2,
        y: -length.parse(parameters.h) / 2 - 0.2,
      },
      {
        x: length.parse(parameters.p) / 2 + 0.2,
        y: -length.parse(parameters.h) / 2 - 0.2,
      },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  return {
    circuitJson: sodWithoutParsing(parameters).concat(
      silkscreenLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

// Get coordinates for SOD pads
export const getSodCoords = (parameters: {
  pn: number
  p: number
}) => {
  const { pn, p } = parameters

  if (pn === 1) {
    return { x: -p / 2, y: 0 }
    // biome-ignore lint/style/noUselessElse: <explanation>
  } else {
    return { x: p / 2, y: 0 }
  }
}

// Function to generate SOD pads
export const sodWithoutParsing = (parameters: z.infer<typeof sod_def>) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords({
      pn: i,
      p: Number.parseFloat(parameters.p),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/sod882d.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const sod_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("1.90mm"),
  h: z.string().default("1.33mm"),
  pl: z.string().default("0.5mm"),
  pw: z.string().default("0.7mm"),
  p: z.string().default("0.8mm"),
})

export const sod882d = (
  raw_params: z.input<typeof sod_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = sod_def.parse(raw_params)

  // Define silkscreen reference text
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h) + 0.1,
    0.3,
  )

  // Define silkscreen path that goes till half of the second pad
  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length.parse(parameters.p) / 2 + 0.1,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2,
        y: -length.parse(parameters.h) / 2,
      },
      {
        x: length.parse(parameters.p) / 2 + 0.1,
        y: -length.parse(parameters.h) / 2,
      },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  return {
    circuitJson: sodWithoutParsing(parameters).concat(
      silkscreenLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

// Get coordinates for SOD pads
export const getSodCoords = (parameters: {
  pn: number
  p: number
}) => {
  const { pn, p } = parameters

  if (pn === 1) {
    return { x: -p / 2, y: 0 }
    // biome-ignore lint/style/noUselessElse: <explanation>
  } else {
    return { x: p / 2, y: 0 }
  }
}

// Function to generate SOD pads
export const sodWithoutParsing = (parameters: z.infer<typeof sod_def>) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords({
      pn: i,
      p: Number.parseFloat(parameters.p),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/sod923.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const sod_def = z.object({
  fn: z.string(),
  num_pins: z.literal(2).default(2),
  w: z.string().default("1.4mm"),
  h: z.string().default("0.9mm"),
  pl: z.string().default("0.35mm"),
  pw: z.string().default("0.25mm"),
  p: z.string().default("1.2mm"),
})

export const sod923 = (
  raw_params: z.input<typeof sod_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = sod_def.parse(raw_params)

  // Define silkscreen reference text
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h),
    0.3,
  )

  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      {
        x: length.parse(parameters.p) / 2 + 0.15,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.4,
        y: length.parse(parameters.h) / 2,
      },
      {
        x: -length.parse(parameters.w) / 2 - 0.4,
        y: -length.parse(parameters.h) / 2,
      },
      {
        x: length.parse(parameters.p) / 2 + 0.15,
        y: -length.parse(parameters.h) / 2,
      },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  return {
    circuitJson: sodWithoutParsing(parameters).concat(
      silkscreenLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
    ),
    parameters,
  }
}

// Get coordinates for SOD pads
export const getSodCoords = (parameters: {
  pn: number
  p: number
}) => {
  const { pn, p } = parameters

  if (pn === 1) {
    return { x: -p / 2, y: 0 }
    // biome-ignore lint/style/noUselessElse: <explanation>
  } else {
    return { x: p / 2, y: 0 }
  }
}

// Function to generate SOD pads
export const sodWithoutParsing = (parameters: z.infer<typeof sod_def>) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getSodCoords({
      pn: i,
      p: Number.parseFloat(parameters.p),
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/fn/soic.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { platedhole } from "../helpers/platedhole"
import { z } from "zod"
import { length } from "circuit-json"
import type { NowDefined } from "../helpers/zod/now-defined"
import { u_curve } from "../helpers/u-curve"
import { rectpad } from "src/helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "../helpers/silkscreenRef"
export const extendSoicDef = (newDefaults: {
  w?: string
  p?: string
  num_pins?: number
  legsoutside?: boolean
}) =>
  z
    .object({
      fn: z.string(),
      num_pins: z.number().optional().default(8),
      w: length.default(length.parse(newDefaults.w ?? "5.3mm")),
      p: length.default(length.parse(newDefaults.p ?? "1.27mm")),
      pw: length.optional(),
      pl: length.optional(),
      legsoutside: z
        .boolean()
        .optional()
        .default(newDefaults.legsoutside ?? false),
    })
    .transform((v) => {
      // Default inner diameter and outer diameter
      if (!v.pw && !v.pl) {
        v.pw = length.parse("0.6mm")
        v.pl = length.parse("1.0mm")
      } else if (!v.pw) {
        v.pw = v.pl! * (0.6 / 1.0)
      } else if (!v.pl) {
        v.pl = v.pw! * (1.0 / 0.6)
      }

      return v as NowDefined<typeof v, "w" | "p" | "pw" | "pl">
    })

export const soic_def = extendSoicDef({})
export type SoicInput = z.infer<typeof soic_def>

export const getCcwSoicCoords = (parameters: {
  num_pins: number
  pn: number
  w: number
  p: number
  pl: number
  legsoutside?: boolean
  widthincludeslegs?: boolean
}) => {
  if (parameters.widthincludeslegs !== undefined) {
    parameters.legsoutside = !parameters.widthincludeslegs
  }
  const { num_pins, pn, w, p, pl, legsoutside } = parameters
  /** pin height */
  const ph = num_pins / 2
  const isLeft = pn <= ph

  /** Number of gaps between pins on each side, e.g. 4 pins = 3 spaces */
  const leftPinGaps = ph - 1

  /** gap size (pitch) */
  const gs = p

  const h = gs * leftPinGaps

  const legoffset = legsoutside ? pl / 2 : -pl / 2

  if (isLeft) {
    // The y position starts at h/2, then goes down by gap size
    // for each pin
    return { x: -w / 2 - legoffset, y: h / 2 - (pn - 1) * gs }
  } else {
    // The y position starts at -h/2, then goes up by gap size
    return { x: w / 2 + legoffset, y: -h / 2 + (pn - ph - 1) * gs }
  }
}

/**
 * Returns the plated holes for a SOIC package.
 */
export const soic = (raw_params: {
  soic: true
  num_pins: number
  w: number
  p?: number
  id?: string | number
  od?: string | number
}): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = soic_def.parse(raw_params)
  return {
    circuitJson: soicWithoutParsing(parameters) as AnySoupElement[],
    parameters,
  }
}

export const soicWithoutParsing = (parameters: z.infer<typeof soic_def>) => {
  const pads: AnySoupElement[] = []
  for (let i = 0; i < parameters.num_pins; i++) {
    const { x, y } = getCcwSoicCoords({
      num_pins: parameters.num_pins,
      pn: i + 1,
      w: parameters.w,
      p: parameters.p ?? 1.27,
      pl: parameters.pl,
      legsoutside: parameters.legsoutside,
    })
    pads.push(
      rectpad(i + 1, x, y, parameters.pl ?? "1mm", parameters.pw ?? "0.6mm"),
    )
  }

  /** silkscreen width */
  const m = Math.min(1, parameters.p / 2)
  const sw =
    parameters.w - (parameters.legsoutside ? 0 : parameters.pl * 2) - 0.2
  const sh = (parameters.num_pins / 2 - 1) * parameters.p + parameters.pw + m
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    sh / 2 + 0.4,
    sh / 12,
  )
  const silkscreenBorder: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    stroke_width: 0.1,
    route: [
      { x: -sw / 2, y: -sh / 2 },
      { x: -sw / 2, y: sh / 2 },
      // Little U shape at the top
      ...u_curve.map(({ x, y }) => ({
        x: (x * sw) / 6,
        y: (y * sw) / 6 + sh / 2,
      })),
      { x: sw / 2, y: sh / 2 },
      { x: sw / 2, y: -sh / 2 },
      { x: -sw / 2, y: -sh / 2 },
    ],
  }

  return [...pads, silkscreenBorder, silkscreenRefText] as AnySoupElement[]
}

================
File: src/fn/sop8.ts
================
import type { AnySoupElement, PcbSilkscreenPath } from "circuit-json"
import { extendSoicDef, type SoicInput, getCcwSoicCoords } from "./soic"
import { rectpad } from "src/helpers/rectpad"
import { type SilkscreenRef, silkscreenRef } from "src/helpers/silkscreenRef"

export const sop8_def = extendSoicDef({})

export const sop8 = (
  raw_params: SoicInput,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = sop8_def.parse(raw_params)
  const pads: AnySoupElement[] = []

  for (let i = 0; i < parameters.num_pins; i++) {
    const { x, y } = getCcwSoicCoords({
      num_pins: parameters.num_pins,
      pn: i + 1,
      w: parameters.w,
      p: parameters.p ?? 1.27,
      pl: parameters.pl,
      widthincludeslegs: true,
    })
    pads.push(
      rectpad(i + 1, x, y, parameters.pl ?? "1.5mm", parameters.pw ?? "0.6mm"),
    )
  }

  const sh = (parameters.num_pins / 2 - 1) * parameters.p + parameters.pw
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    sh / 2 - 0.5,
    sh / 12,
  )

  const silkscreenLine: PcbSilkscreenPath = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "",
    type: "pcb_silkscreen_path",
    route: [
      { x: -parameters.w / 3, y: sh / 2 + 0.2 },
      { x: parameters.w / 3, y: sh / 2 + 0.2 },
    ],
    stroke_width: 0.1,
  }

  return {
    circuitJson: [
      ...pads,
      silkscreenRefText,
      silkscreenLine,
    ] as AnySoupElement[],
    parameters,
  }
}

================
File: src/fn/sot223.ts
================
import type { AnyCircuitElement, PcbSilkscreenPath } from "circuit-json"
import { type SilkscreenRef, silkscreenRef } from "src/helpers/silkscreenRef"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { extendSoicDef, soicWithoutParsing } from "./soic"

export const sot223_def = z.object({
  fn: z.string(),
  num_pins: z.number().default(4),
  w: z.string().default("8.50mm"),
  h: z.string().default("6.90mm"),
  pl: z.string().default("2mm"),
  pw: z.string().default("1.5mm"),
  p: z.string().default("2.30mm"),
  string: z.string().optional(),
})

export const sot223 = (
  raw_params: z.input<typeof sot223_def>,
): { circuitJson: AnyCircuitElement[]; parameters: any } => {
  const match = raw_params.string?.match(/^sot223_(\d+)/)
  const numPins = match ? Number.parseInt(match[1]!, 10) : 4

  if (numPins === 8) {
    const parameters = sot223_8_def.parse({
      ...raw_params,
      num_pins: numPins,
    })
    return {
      circuitJson: soicWithoutParsing(parameters),
      parameters: parameters,
    }
  }

  const parameters = sot223_def.parse({
    ...raw_params,
    num_pins: numPins,
  })

  if (parameters.num_pins === 4) {
    return {
      circuitJson: sot223_4(parameters),
      parameters: parameters,
    }
  }
  if (parameters.num_pins === 5) {
    return {
      circuitJson: sot223_5(parameters),
      parameters: parameters,
    }
  }
  if (parameters.num_pins === 6) {
    return {
      circuitJson: sot223_6(parameters),
      parameters: parameters,
    }
  }
  throw new Error("Invalid number of pins")
}
export const get2CcwSot223Coords = (parameters: {
  num_pins: number
  pn: number
  w: number
  h: number
  pl: number
  p: number
}) => {
  const { pn, w, h, pl, p } = parameters

  if (pn === 1) {
    return { x: -w / 2 + 1.1, y: p }
  }
  if (pn === 2) {
    return { x: -w / 2 + 1.1, y: 0 }
  }
  if (pn === 3) {
    return { x: -w / 2 + 1.1, y: -p }
  }

  return { x: w / 2 - 1.1, y: 0 }
}

export const sot223_4 = (parameters: z.infer<typeof sot223_def>) => {
  const pads: AnyCircuitElement[] = []

  for (let i = 0; i < parameters.num_pins; i++) {
    const { x, y } = get2CcwSot223Coords({
      num_pins: parameters.num_pins,
      pn: i + 1,
      w: Number.parseFloat(parameters.w),
      h: Number.parseFloat(parameters.h),
      pl: Number.parseFloat(parameters.pl),
      p: Number.parseFloat(parameters.p),
    })

    const pinWidth = i === 3 ? 3.8 : Number.parseFloat(parameters.pw)

    pads.push(rectpad(i + 1, x, y, Number.parseFloat(parameters.pl), pinWidth))
  }

  const silkscreenRefText: SilkscreenRef = silkscreenRef(0, 0, 0.3)

  const width = Number.parseFloat(parameters.w) / 2 - 2.4
  const height = Number.parseFloat(parameters.h) / 2
  const silkscreenPath1: PcbSilkscreenPath = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    route: [
      { x: -width, y: height },
      { x: width, y: height },
      { x: width, y: height / 2 + 0.5 },
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1,
  }
  const silkscreenPath2: PcbSilkscreenPath = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_2",
    route: [
      { x: -width, y: -height },
      { x: width, y: -height },
      { x: width, y: -height / 2 - 0.5 },
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1,
  }

  return [
    ...pads,
    silkscreenPath1,
    silkscreenPath2,
    silkscreenRefText as AnyCircuitElement,
  ]
}

export const sot223_8_def = extendSoicDef({
  p: "0.90mm",
  w: "2.8mm",
  legsoutside: true,
})

export const get2CcwSot2235Coords = (parameters: {
  h: number
  p: number
  pn: number
  w: number
}) => {
  const { p, h, pn, w } = parameters
  if (pn === 1) {
    return { x: -w / 2 + 1.2, y: p / 2 + p }
  }
  if (pn === 2) {
    return { x: -w / 2 + 1.2, y: p / 2 }
  }
  if (pn === 3) {
    return { x: -w / 2 + 1.2, y: -p / 2 }
  }
  if (pn === 4) {
    return { x: -w / 2 + 1.2, y: -p / 2 - p }
  }
  if (pn === 5) {
    return { x: w / 2 - 1, y: 0 }
  }
  throw new Error("Invalid pin number")
}

export const sot223_5 = (parameters: z.infer<typeof sot223_def>) => {
  const pads: AnyCircuitElement[] = []
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = get2CcwSot2235Coords({
      h: Number.parseFloat(parameters.h),
      p: 1.5,
      pn: i,
      w: Number.parseFloat(parameters.w),
    })

    let pinWidth = Number.parseFloat(parameters.pw)
    let pinLength = Number.parseFloat(parameters.pl)

    if (i === 5) {
      pinWidth = 3.4
      pinLength = 1.8
    } else {
      pinWidth = 1
      pinLength = 2.2
    }

    pads.push(rectpad(i, x, y, pinLength, pinWidth))
  }

  const width = Number.parseFloat(parameters.w) / 2 - 2.4
  const height = Number.parseFloat(parameters.h) / 2
  const silkscreenPath1: PcbSilkscreenPath = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    route: [
      { x: -width, y: height },
      { x: width, y: height },
      { x: width, y: height / 2 + 0.5 },
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1,
  }
  const silkscreenPath2: PcbSilkscreenPath = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_2",
    route: [
      { x: -width, y: -height },
      { x: width, y: -height },
      { x: width, y: -height / 2 - 0.5 },
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1,
  }

  const silkscreenRefText: SilkscreenRef = silkscreenRef(0, 0, 0.3)

  return [...pads, silkscreenPath1, silkscreenPath2, silkscreenRefText]
}

export const get2CcwSot2236Coords = (parameters: {
  h: number
  p: number
  pn: number
  w: number
}) => {
  const { p, h, pn, w } = parameters
  if (pn === 1) {
    return { x: -w / 2 + 1.2, y: 2 * p }
  }
  if (pn === 2) {
    return { x: -w / 2 + 1.2, y: p }
  }
  if (pn === 3) {
    return { x: -w / 2 + 1.2, y: 0 }
  }
  if (pn === 4) {
    return { x: -w / 2 + 1.2, y: -p }
  }
  if (pn === 5) {
    return { x: -w / 2 + 1.2, y: -2 * p }
  }
  if (pn === 6) {
    return { x: w / 2 - 1.175, y: 0 }
  }
  throw new Error("Invalid pin number")
}

export const sot223_6 = (parameters: z.infer<typeof sot223_def>) => {
  const pads: AnyCircuitElement[] = []
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = get2CcwSot2236Coords({
      h: Number.parseFloat(parameters.h),
      p: 1.3,
      pn: i,
      w: 8.7,
    })

    let pinWidth = Number.parseFloat(parameters.pw)
    let pinLength = Number.parseFloat(parameters.pl)

    if (i === 6) {
      pinWidth = 3.4
      pinLength = 2.15
    } else {
      pinWidth = 0.6
      pinLength = 2.2
    }

    pads.push(rectpad(i, x, y, pinLength, pinWidth))
  }

  const width = Number.parseFloat(parameters.w) / 2 - 2.4
  const height = Number.parseFloat(parameters.h) / 2
  const silkscreenPath1: PcbSilkscreenPath = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    route: [
      { x: -width, y: height },
      { x: width, y: height },
      { x: width, y: height / 2 + 0.5 },
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1,
  }
  const silkscreenPath2: PcbSilkscreenPath = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_2",
    route: [
      { x: -width, y: -height },
      { x: width, y: -height },
      { x: width, y: -height / 2 - 0.5 },
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1,
  }

  const silkscreenRefText: SilkscreenRef = silkscreenRef(0, 0, 0.3)

  return [...pads, silkscreenPath1, silkscreenPath2, silkscreenRefText]
}

================
File: src/fn/sot23.ts
================
import type { AnyCircuitElement, PcbSilkscreenPath } from "circuit-json"
import { type SilkscreenRef, silkscreenRef } from "src/helpers/silkscreenRef"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { extendSoicDef, soicWithoutParsing } from "./soic"

export const sot23_def = z.object({
  fn: z.string(),
  num_pins: z.number().default(3),
  w: z.string().default("1.92mm"),
  h: z.string().default("2.74mm"),
  pl: z.string().default("0.8mm"),
  pw: z.string().default("0.764mm"),
  p: z.string().default("0.95mm"),
  string: z.string().optional(),
})

export const sot23_6_or_8_def = extendSoicDef({
  p: "0.95mm",
  w: "1.6mm",
  legsoutside: true,
})

export const sot23 = (
  raw_params: z.input<typeof sot23_def>,
): { circuitJson: AnyCircuitElement[]; parameters: any } => {
  const match = raw_params.string?.match(/^sot23_(\d+)/)
  const numPins = match ? Number.parseInt(match[1]!, 10) : 3

  if (numPins === 6 || numPins === 8) {
    const parameters = sot23_6_or_8_def.parse({
      ...raw_params,
      num_pins: numPins,
    })
    return {
      circuitJson: soicWithoutParsing(parameters),
      parameters: parameters,
    }
  }

  const parameters = sot23_def.parse({
    ...raw_params,
    num_pins: numPins,
  })

  if (parameters.num_pins === 3) {
    return {
      circuitJson: sot23_3(parameters),
      parameters: parameters,
    }
  }
  if (parameters.num_pins === 5) {
    return {
      circuitJson: sot23_5(parameters),
      parameters: parameters,
    }
  }
  throw new Error("Invalid number of pins")
}
export const getCcwSot23Coords = (parameters: {
  num_pins: number
  pn: number
  w: number
  h: number
  pl: number
}) => {
  const { pn, w, h, pl } = parameters

  if (pn === 1) {
    return { x: -1.7, y: 0 }
  }
  if (pn === 2) {
    return { x: 1.7, y: -0.95 }
  }

  return { x: 1.7, y: 0.95 }
}

export const sot23_3 = (parameters: z.infer<typeof sot23_def>) => {
  const pads: AnyCircuitElement[] = []

  for (let i = 0; i < parameters.num_pins; i++) {
    const { x, y } = getCcwSot23Coords({
      num_pins: parameters.num_pins,
      pn: i + 1,
      w: Number.parseFloat(parameters.w),
      h: Number.parseFloat(parameters.h),
      pl: Number.parseFloat(parameters.pl),
    })
    pads.push(
      rectpad(
        i + 1,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    Number.parseInt(parameters.h),
    0.3,
  )
  return [...pads, silkscreenRefText as AnyCircuitElement]
}

export const getCcwSot235Coords = (parameters: {
  h: number
  p: number
  pn: number
}) => {
  const { p, h, pn } = parameters
  if (pn === 1) {
    return { x: -h / 2 - 0.5, y: p }
  }
  if (pn === 2) {
    return { x: -h / 2 - 0.5, y: 0 }
  }
  if (pn === 3) {
    return { x: -h / 2 - 0.5, y: -p }
  }
  if (pn === 4) {
    return { x: h / 2 + 0.5, y: -p }
  }
  if (pn === 5) {
    return { x: h / 2 + 0.5, y: p }
  }
  throw new Error("Invalid pin number")
}

export const sot23_5 = (parameters: z.infer<typeof sot23_def>) => {
  const pads: AnyCircuitElement[] = []
  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getCcwSot235Coords({
      h: Number.parseFloat(parameters.h),
      p: Number.parseFloat(parameters.p),
      pn: i,
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }

  const width =
    ((parameters.num_pins + 1) / 2) * Number.parseFloat(parameters.p)
  const height = Number.parseFloat(parameters.h)
  const silkscreenPath1: PcbSilkscreenPath = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    route: [
      { x: -width / 3, y: height / 2 + Number.parseFloat(parameters.p) / 1.3 },
      { x: width / 3, y: height / 2 + Number.parseFloat(parameters.p) / 1.3 },
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.05,
  }
  const silkscreenPath2: PcbSilkscreenPath = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_2",
    route: [
      { x: -width / 3, y: -height / 2 - Number.parseFloat(parameters.p) / 1.3 },
      { x: width / 3, y: -height / 2 - Number.parseFloat(parameters.p) / 1.3 },
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.05,
  }
  const silkscreenRefText: SilkscreenRef = silkscreenRef(0, height + 0.3, 0.3)
  const pin1Position = getCcwSot235Coords({
    h: Number.parseFloat(parameters.h),
    p: Number.parseFloat(parameters.p),
    pn: 1,
  })
  pin1Position.x = pin1Position.x - Number.parseFloat(parameters.pw) * 1.5
  const triangleHeight = 0.7 // Adjust triangle size as needed
  const triangleWidth = 0.3 // Adjust triangle width as needed
  const pin1Indicator: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "pin1_indicator",
    route: [
      {
        x: pin1Position.x + triangleHeight / 2,
        y: pin1Position.y,
      }, // Tip of the triangle (pointing right)
      {
        x: pin1Position.x - triangleHeight / 2,
        y: pin1Position.y + triangleWidth / 2,
      }, // Bottom corner of the base
      {
        x: pin1Position.x - triangleHeight / 2,
        y: pin1Position.y - triangleWidth / 2,
      }, // Top corner of the base
      {
        x: pin1Position.x + triangleHeight / 2,
        y: pin1Position.y,
      }, // Close the path at the tip
    ],
    stroke_width: 0.05,
  }

  return [
    ...pads,
    silkscreenRefText,
    silkscreenPath1,
    silkscreenPath2,
    pin1Indicator as AnyCircuitElement,
  ]
}

================
File: src/fn/sot363.ts
================
import type { AnySoupElement } from "circuit-json"
import { extendSoicDef, soicWithoutParsing } from "./soic"
import type { z } from "zod"

export const sot363_def = extendSoicDef({})

export const sot363 = (
  raw_params: z.input<typeof sot363_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = sot363_def.parse({
    fn: "sot363",
    num_pins: 6,
    w: 1.94,
    p: 0.65,
    pw: 0.3,
    pl: 0.7,
    legoutside: true,
  })

  return {
    circuitJson: soicWithoutParsing(parameters),
    parameters,
  }
}

================
File: src/fn/sot563.ts
================
import type { AnySoupElement } from "circuit-json"
import { extendSoicDef, soicWithoutParsing } from "./soic"
import type { z } from "zod"

export const sot563_def = extendSoicDef({})

export const sot563 = (
  raw_params: z.input<typeof sot563_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = sot563_def.parse({
    fn: "sot563",
    num_pins: 6,
    w: 1.94,
    p: 0.5,
    pw: 0.3,
    pl: 0.67,
    legoutside: true,
  })
  return {
    circuitJson: soicWithoutParsing(parameters),
    parameters,
  }
}

================
File: src/fn/sot723.ts
================
import { length, type AnySoupElement } from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"

export const sot723_def = z.object({
  fn: z.string(),
  num_pins: z.literal(3).default(3),
  w: z.string().default("1.2mm"),
  h: z.string().default("1.2mm"),
  pl: z.string().default("0.3mm"),
  pw: z.string().default("0.32mm"),
})

export const sot723 = (
  raw_params: z.input<typeof sot723_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = sot723_def.parse(raw_params)
  const pad = sot723WithoutParsing(parameters)
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0.4,
    length.parse(parameters.h),
    0.2,
  )
  return {
    circuitJson: [...pad, silkscreenRefText as AnySoupElement],
    parameters,
  }
}

export const getCcwSot723Coords = (parameters: {
  num_pins: number
  pn: number
  w: number
  h: number
  pl: number
}) => {
  const { pn, w, h, pl } = parameters

  if (pn === 1) {
    return { x: 0, y: 0 }
  } else if (pn === 2) {
    return { x: 1, y: -0.4 }
  } else {
    return { x: 1, y: 0.4 }
  }
}

export const sot723WithoutParsing = (
  parameters: z.infer<typeof sot723_def>,
) => {
  const pads: AnySoupElement[] = []

  for (let i = 0; i < 3; i++) {
    const { x, y } = getCcwSot723Coords({
      num_pins: parameters.num_pins,
      pn: i + 1,
      w: Number.parseFloat(parameters.w),
      h: Number.parseFloat(parameters.h),
      pl: Number.parseFloat(parameters.pl),
    })
    pads.push(
      rectpad(
        i + 1,
        x,
        y,
        Number.parseFloat(parameters.pl),
        i !== 0 ? Number.parseFloat(parameters.pw) : 0.42,
      ),
    )
  }

  return pads
}

================
File: src/fn/sot89.ts
================
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import type { AnyCircuitElement, PcbSilkscreenPath } from "circuit-json"
import { type SilkscreenRef, silkscreenRef } from "src/helpers/silkscreenRef"

export const sot89_def = z.object({
  fn: z.string(),
  num_pins: z.union([z.literal(3), z.literal(5)]).default(3),
  w: z.string().default("4.80mm"),
  h: z.string().default("4.80mm"),
  pl: z.string().default("1.3mm"),
  pw: z.string().default("0.9mm"),
  p: z.string().default("1.5mm"),
  string: z.string().optional(),
})

export const sot89_3 = (parameters: z.infer<typeof sot89_def>) => {
  const pads: AnyCircuitElement[] = []

  const padGap = Number.parseFloat(parameters.p)
  const padWidth = Number.parseFloat(parameters.pw)
  const length = Number.parseFloat(parameters.w)
  const padHeight = Number.parseFloat(parameters.pl)

  pads.push(
    rectpad(1, -length / 2, padGap, padHeight, padWidth),
    rectpad(2, -length / 2 + (1.5 - 1.3) / 2, 0, 1.5, padWidth),
    rectpad(3, -length / 2, -padGap, padHeight, padWidth),
  )

  const silkscreenRefText: SilkscreenRef = silkscreenRef(0, 0, 0.3)

  const width = Number.parseFloat(parameters.w) / 2 - 1
  const height = Number.parseFloat(parameters.h) / 2
  const silkscreenPath1: PcbSilkscreenPath = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    route: [
      { x: -width, y: height },
      { x: width, y: height },
      { x: width, y: height / 2 + 0.5 },
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1,
  }
  const silkscreenPath2: PcbSilkscreenPath = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_2",
    route: [
      { x: -width, y: -height },
      { x: width, y: -height },
      { x: width, y: -height / 2 - 0.5 },
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1,
  }

  return [
    ...pads,
    silkscreenPath1,
    silkscreenPath2,
    silkscreenRefText as AnyCircuitElement,
  ]
}

export const sot89_5 = (parameters: z.infer<typeof sot89_def>) => {
  const pads: AnyCircuitElement[] = []

  const padGap = Number.parseFloat(parameters.p)
  const padWidth = Number.parseFloat(parameters.pw)
  const length = Number.parseFloat(parameters.w)

  pads.push(
    rectpad(1, -1.85, -1.5, 1.5, 0.7),
    rectpad(2, -1.85, 1.5, 1.5, 0.7),
    rectpad(3, 0, 0, 0.8, 2),
    rectpad(4, 1.85, -1.5, 1.5, 0.7),
    rectpad(5, 1.85, 1.5, 1.5, 0.7),
  )

  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    Number.parseFloat(parameters.h) / 2 + 0.5,
    0.3,
  )

  const width = Number.parseFloat(parameters.w) / 2 - 1
  const height = Number.parseFloat(parameters.h) / 2
  const silkscreenPath1: PcbSilkscreenPath = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_1",
    route: [
      { x: -width, y: height },
      { x: width, y: height },
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1,
  }
  const silkscreenPath2: PcbSilkscreenPath = {
    layer: "top",
    pcb_component_id: "",
    pcb_silkscreen_path_id: "silkscreen_path_2",
    route: [
      { x: -width, y: -height },
      { x: width, y: -height },
    ],
    type: "pcb_silkscreen_path",
    stroke_width: 0.1,
  }

  return [
    ...pads,
    silkscreenPath1,
    silkscreenPath2,
    silkscreenRefText as AnyCircuitElement,
  ]
}

export const sot89 = (
  raw_params: z.input<typeof sot89_def>,
): { circuitJson: AnyCircuitElement[]; parameters: any } => {
  const match = raw_params.string?.match(/^sot89_(\d+)/)
  const numPins = match ? Number.parseInt(match[1]!, 10) : 3

  const parameters = sot89_def.parse({
    ...raw_params,
    num_pins: numPins,
  })

  if (parameters.num_pins === 3) {
    return {
      circuitJson: sot89_3(parameters),
      parameters: parameters,
    }
  }

  if (parameters.num_pins === 5) {
    return {
      circuitJson: sot89_5(parameters),
      parameters: parameters,
    }
  }

  throw new Error("Invalid number of pins for SOT89")
}

================
File: src/fn/ssop.ts
================
import type { AnySoupElement } from "circuit-json"
import { extendSoicDef, soicWithoutParsing, type SoicInput } from "./soic"

// TODO we should accept MS-012 or MS-013

export const ssop_def = extendSoicDef({
  w: "3.9mm",
  p: "1.27mm",
})

export const ssop = (
  raw_params: SoicInput,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = ssop_def.parse(raw_params)
  return {
    circuitJson: soicWithoutParsing(parameters),
    parameters,
  }
}

================
File: src/fn/stampboard.ts
================
import {
  length,
  type AnyCircuitElement,
  type PcbPlatedHole,
  type PcbSilkscreenPath,
} from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { platedhole } from "src/helpers/platedhole"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"

export const stampboard_def = z.object({
  fn: z.string(),
  w: length.default("22.58mm"),
  h: length.optional(),
  left: length.optional().default(20),
  right: length.optional().default(20),
  top: length.optional().default(2),
  bottom: length.optional().default(2),
  p: length.default(length.parse("2.54mm")),
  pw: length.default(length.parse("1.6mm")),
  pl: length.default(length.parse("2.4mm")),
  innerhole: z.boolean().default(false),
  innerholeedgedistance: length.default(length.parse("1.61mm")),
})

export type Stampboard_def = z.input<typeof stampboard_def>

const getHeight = (parameters: Stampboard_def) => {
  const params = stampboard_def.parse(parameters)
  if (params.left && params.right) {
    return Math.max(params.left, params.right) * params.p
  }
  if (params.left) {
    return params.left * params.p
  }
  if (params.right) {
    return params.right * params.p
  }
  return 51 // Default height if no pins are provided
}
const getTriangleDir = (x: number, y: number, side: string) => {
  let routes: { x: number; y: number }[] = []
  const triangleHeight = 1 // Adjust triangle size as needed
  const triangleWidth = 0.6 // Adjust triangle width as needed
  if (side === "right") {
    routes = [
      {
        x: x + triangleHeight / 2,
        y: y,
      }, // Tip of the triangle (pointing right)
      {
        x: x - triangleHeight / 2,
        y: y + triangleWidth / 2,
      }, // Bottom corner of the base
      {
        x: x - triangleHeight / 2,
        y: y - triangleWidth / 2,
      }, // Top corner of the base
      {
        x: x + triangleHeight / 2,
        y: y,
      }, // Close the path at the tip
    ]
  }
  if (side === "left") {
    routes = [
      {
        x: x - triangleHeight / 2,
        y: y,
      }, // Tip of the triangle (pointing left)
      {
        x: x + triangleHeight / 2,
        y: y + triangleWidth / 2,
      }, // Top corner of the base
      {
        x: x + triangleHeight / 2,
        y: y - triangleWidth / 2,
      }, // Bottom corner of the base
      {
        x: x - triangleHeight / 2,
        y: y,
      }, // Close the path at the tip
    ]
  }
  if (side === "top") {
    routes = [
      {
        x: x,
        y: y + triangleHeight / 2,
      }, // Tip of the triangle (pointing up)
      {
        x: x - triangleWidth / 2,
        y: y - triangleHeight / 2,
      }, // Left corner of the base
      {
        x: x + triangleWidth / 2,
        y: y - triangleHeight / 2,
      }, // Right corner of the base
      {
        x: x,
        y: y + triangleHeight / 2,
      }, // Close the path at the tip
    ]
  }
  if (side === "bottom") {
    routes = [
      {
        x: x,
        y: y - triangleHeight / 2,
      }, // Tip of the triangle (pointing down)
      {
        x: x - triangleWidth / 2,
        y: y + triangleHeight / 2,
      }, // Left corner of the base
      {
        x: x + triangleWidth / 2,
        y: y + triangleHeight / 2,
      }, // Right corner of the base
      {
        x: x,
        y: y - triangleHeight / 2,
      }, // Close the path at the tip
    ]
  }
  return routes
}

export const stampboard = (
  raw_params: Stampboard_def,
): { circuitJson: AnyCircuitElement[]; parameters: any } => {
  const params = stampboard_def.parse(raw_params)
  const height = params.h ?? getHeight(params)
  const rectpads: AnyCircuitElement[] = []
  const holes: PcbPlatedHole[] = []
  let routes: { x: number; y: number }[] = []
  const innerDiameter = 1
  const outerDiameter = 1.2
  const totalPadsNumber =
    params.left + params.right + (params.bottom ?? 0) + (params.top ?? 0)
  if (params.right) {
    const yoff = -((params.right - 1) / 2) * params.p
    for (let i = 0; i < params.right; i++) {
      if (i === 0 && !params.left && !params.bottom) {
        routes = getTriangleDir(
          params.w / 2 - params.pl * 1.4,
          yoff + i * params.p,
          "right",
        )
      }
      rectpads.push(
        rectpad(
          i + 1 + params.left + (params.bottom ?? 0),
          params.w / 2 - params.pl / 2,
          yoff + i * params.p,
          params.pl,
          params.pw,
        ),
      )
      if (params.innerhole) {
        holes.push(
          platedhole(
            i + 1 + params.left + (params.bottom ?? 0) + totalPadsNumber,
            params.w / 2,
            yoff + i * params.p,
            innerDiameter,
            outerDiameter,
          ),
        )
        holes.push(
          platedhole(
            i + 1 + params.left + (params.bottom ?? 0) + totalPadsNumber * 2,
            params.w / 2 - params.innerholeedgedistance,
            yoff + i * params.p,
            innerDiameter,
            outerDiameter,
          ),
        )
      }
    }
  }
  if (params.left) {
    const yoff = -((params.left - 1) / 2) * params.p
    for (let i = 0; i < params.left; i++) {
      if (i === params.left - 1) {
        routes = getTriangleDir(
          -params.w / 2 + params.pl * 1.4,
          yoff + i * params.p,
          "left",
        )
      }
      rectpads.push(
        rectpad(
          i + 1,
          -params.w / 2 + params.pl / 2,
          yoff + i * params.p,
          params.pl,
          params.pw,
        ),
      )
      if (params.innerhole) {
        holes.push(
          platedhole(
            i + 1 + totalPadsNumber,
            -params.w / 2,
            yoff + i * params.p,
            innerDiameter,
            outerDiameter,
          ),
        )
        holes.push(
          platedhole(
            i + 1 + totalPadsNumber * 2,
            -params.w / 2 + params.innerholeedgedistance,
            yoff + i * params.p,
            innerDiameter,
            outerDiameter,
          ),
        )
      }
    }
  }
  if (params.top) {
    const xoff = -((params.top - 1) / 2) * params.p
    for (let i = 0; i < params.top; i++) {
      if (
        i === params.top - 1 &&
        !params.left &&
        !params.bottom &&
        !params.right
      ) {
        routes = getTriangleDir(
          xoff + i * params.p,
          height / 2 - params.pl * 1.4,
          "top",
        )
      }
      rectpads.push(
        rectpad(
          i + 1 + params.left + params.right + (params.bottom ?? 0),
          xoff + i * params.p,
          height / 2 - params.pl / 2,
          params.pw,
          params.pl,
        ),
      )
      if (params.innerhole) {
        holes.push(
          platedhole(
            i +
              1 +
              params.left +
              params.right +
              (params.bottom ?? 0) +
              totalPadsNumber,
            xoff + i * params.p,
            height / 2,
            innerDiameter,
            outerDiameter,
          ),
        )
        holes.push(
          platedhole(
            i +
              1 +
              params.left +
              params.right +
              (params.bottom ?? 0) +
              totalPadsNumber * 2,
            xoff + i * params.p,
            height / 2 - params.innerholeedgedistance,
            innerDiameter,
            outerDiameter,
          ),
        )
      }
    }
  }
  if (params.bottom) {
    const xoff = -((params.bottom - 1) / 2) * params.p
    for (let i = 0; i < params.bottom; i++) {
      if (i === 0 && !params.left) {
        routes = getTriangleDir(
          xoff + i * params.p,
          -height / 2 + params.pl * 1.4,
          "bottom",
        )
      }
      rectpads.push(
        rectpad(
          i + 1 + params.left,
          xoff + i * params.p,
          -height / 2 + params.pl / 2,
          params.pw,
          params.pl,
        ),
      )
      if (params.innerhole) {
        holes.push(
          platedhole(
            i + 1 + params.left + totalPadsNumber,
            xoff + i * params.p,
            -height / 2,
            innerDiameter,
            outerDiameter,
          ),
        )
        holes.push(
          platedhole(
            i + 1 + params.left + totalPadsNumber * 2,
            xoff + i * params.p,
            -height / 2 + params.innerholeedgedistance,
            innerDiameter,
            outerDiameter,
          ),
        )
      }
    }
  }

  const silkscreenTriangle: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    pcb_silkscreen_path_id: "pcb_silkscreen_triangle_1",
    pcb_component_id: "2",
    route: routes,
    stroke_width: 0.1,
    layer: "top",
  }

  const silkscreenPath: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    pcb_silkscreen_path_id: "pcb_silkscreen_path_1",
    pcb_component_id: "1",
    route: [
      { x: -params.w / 2, y: height / 2 },
      { x: params.w / 2, y: height / 2 },
      { x: params.w / 2, y: -height / 2 },
      { x: -params.w / 2, y: -height / 2 },
      { x: -params.w / 2, y: height / 2 },
    ],
    stroke_width: 0.1,
    layer: "top",
  }
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    height / 1.8,
    height / 25,
  )
  return {
    circuitJson: [
      ...rectpads,
      ...holes,
      silkscreenPath,
      silkscreenTriangle,
      silkscreenRefText,
    ],
    parameters: params,
  }
}

================
File: src/fn/stampreceiver.ts
================
import {
  length,
  type AnyCircuitElement,
  type PcbPlatedHole,
  type PcbSilkscreenPath,
  type PcbSilkscreenText,
} from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { platedhole } from "src/helpers/platedhole"

export const stampreceiver_def = z.object({
  fn: z.string(),
  w: length.default("22.58mm"),
  h: length.optional(),
  left: length.optional().default(20),
  right: length.optional().default(20),
  top: length.optional().default(2),
  bottom: length.optional().default(2),
  p: length.default(length.parse("2.54mm")),
  pw: length.default(length.parse("1.6mm")),
  pl: length.default(length.parse("3.2mm")),
  innerhole: z.boolean().default(false),
  innerholeedgedistance: length.default(length.parse("1.61mm")),
})

export type Stampreceiver_def = z.input<typeof stampreceiver_def>

const getHeight = (parameters: Stampreceiver_def): number => {
  const params = stampreceiver_def.parse(parameters)

  // Calculate height based on the presence of left and right parameters
  if (params.left && params.right) {
    return Math.max(params.left, params.right) * params.p
  }

  if (params.left) {
    return params.left * params.p
  }

  if (params.right) {
    return params.right * params.p
  }

  // Return default height if neither left nor right is provided
  return 51
}
type Point = { x: number; y: number }
type Direction = "left" | "right" | "top" | "bottom"

const getTriangleDir = (
  x: number,
  y: number,
  side: Direction,
  triangleHeight = 1,
  triangleWidth = 0.6,
): Point[] => {
  const halfHeight = triangleHeight / 2
  const halfWidth = triangleWidth / 2

  const routes: Record<Direction, Point[]> = {
    left: [
      { x: x + halfHeight, y }, // Tip
      { x: x - halfHeight, y: y + halfWidth }, // Bottom corner
      { x: x - halfHeight, y: y - halfWidth }, // Top corner
      { x: x + halfHeight, y }, // Close path
    ],
    right: [
      { x: x - halfHeight, y }, // Tip
      { x: x + halfHeight, y: y + halfWidth }, // Top corner
      { x: x + halfHeight, y: y - halfWidth }, // Bottom corner
      { x: x - halfHeight, y }, // Close path
    ],
    top: [
      { x, y: y - halfHeight }, // Tip
      { x: x - halfWidth, y: y + halfHeight }, // Left corner
      { x: x + halfWidth, y: y + halfHeight }, // Right corner
      { x, y: y - halfHeight }, // Close path
    ],
    bottom: [
      { x, y: y + halfHeight }, // Tip
      { x: x - halfWidth, y: y - halfHeight }, // Left corner
      { x: x + halfWidth, y: y - halfHeight }, // Right corner
      { x, y: y + halfHeight }, // Close path
    ],
  }

  return routes[side]
}
export const stampreceiver = (
  raw_params: Stampreceiver_def,
): { circuitJson: AnyCircuitElement[]; parameters: any } => {
  const params = stampreceiver_def.parse(raw_params)
  const height = params.h ?? getHeight(params)
  const rectpads: AnyCircuitElement[] = []
  const pinLabels: PcbSilkscreenText[] = []
  const holes: PcbPlatedHole[] = []
  const innerDiameter = 1
  const outerDiameter = 1.2
  const totalPadsNumber =
    params.left + params.right + (params.bottom ?? 0) + (params.top ?? 0)
  let routes: { x: number; y: number }[] = []
  let padIndex = 1

  // Process Left Pads (top to bottom)
  if (params.left) {
    const yoff = ((params.left - 1) / 2) * params.p
    for (let i = 0; i < params.left; i++) {
      if (i === 0) {
        routes = getTriangleDir(
          -params.w / 2 - params.pl / 2,
          yoff - i * params.p,
          "left",
        )
      }
      rectpads.push(
        rectpad(
          padIndex,
          -params.w / 2 + params.pl / 2,
          yoff - i * params.p,
          params.pl,
          params.pw,
        ),
      )
      pinLabels.push({
        type: "pcb_silkscreen_text",
        pcb_silkscreen_text_id: `pin_${padIndex}`,
        pcb_component_id: "1",
        layer: "top",
        anchor_position: {
          x: -params.w / 2 + params.pl / 2 - 4.5,
          y: yoff - i * params.p,
        },
        text: `pin${padIndex}`,
        font_size: 0.7,
        font: "tscircuit2024",
        anchor_alignment: "center",
      })
      padIndex++
      params.innerhole &&
        holes.push(
          platedhole(
            padIndex + totalPadsNumber,
            -params.w / 2 + params.innerholeedgedistance,
            yoff - i * params.p,
            innerDiameter,
            outerDiameter,
          ),
        )
    }
  }

  // Process Bottom Pads (right to left)
  if (params.bottom) {
    const xoff = ((params.bottom - 1) / 2) * params.p
    for (let i = params.bottom - 1; i >= 0; i--) {
      rectpads.push(
        rectpad(
          padIndex,
          xoff - i * params.p,
          -height / 2 + params.pl / 2,
          params.pw,
          params.pl,
        ),
      )
      pinLabels.push({
        type: "pcb_silkscreen_text",
        pcb_silkscreen_text_id: `pin_${padIndex}`,
        pcb_component_id: "1",
        layer: "top",
        anchor_position: {
          x: xoff - i * params.p,
          y: -height / 2 + params.pl / 2 - 3.2,
        },
        text: `pin${padIndex}`,
        font_size: 0.7,
        font: "tscircuit2024",
        anchor_alignment: "center",
      })
      padIndex++
      params.innerhole &&
        holes.push(
          platedhole(
            padIndex + totalPadsNumber,
            xoff - i * params.p,
            -height / 2 + params.innerholeedgedistance,
            innerDiameter,
            outerDiameter,
          ),
        )
    }
  }

  // Process Right Pads (bottom to top)
  if (params.right) {
    const yoff = -((params.right - 1) / 2) * params.p
    for (let i = 0; i < params.right; i++) {
      rectpads.push(
        rectpad(
          padIndex,
          params.w / 2 - params.pl / 2,
          yoff + i * params.p,
          params.pl,
          params.pw,
        ),
      )
      pinLabels.push({
        type: "pcb_silkscreen_text",
        pcb_silkscreen_text_id: `pin_${padIndex}`,
        pcb_component_id: "1",
        layer: "top",
        anchor_position: {
          x: params.w / 2 - params.pl / 2 + 3.7,
          y: yoff + i * params.p,
        },
        text: `pin${padIndex}`,
        font_size: 0.7,
        font: "tscircuit2024",
        anchor_alignment: "center",
      })
      padIndex++
      params.innerhole &&
        holes.push(
          platedhole(
            padIndex + totalPadsNumber,
            params.w / 2 - params.innerholeedgedistance,
            yoff + i * params.p,
            innerDiameter,
            outerDiameter,
          ),
        )
    }
  }

  // Process Top Pads (left to right)
  if (params.top) {
    const xoff = -((params.top - 1) / 2) * params.p
    for (let i = params.top - 1; i >= 0; i--) {
      rectpads.push(
        rectpad(
          padIndex,
          xoff + i * params.p,
          height / 2 - params.pl / 2,
          params.pw,
          params.pl,
        ),
      )
      pinLabels.push({
        type: "pcb_silkscreen_text",
        pcb_silkscreen_text_id: `pin_${padIndex}`,
        pcb_component_id: "1",
        layer: "top",
        anchor_position: {
          x: xoff + i * params.p,
          y: height / 2 - params.pl / 2 + 3.2,
        },
        text: `pin${padIndex}`,
        font_size: 0.7,
        font: "tscircuit2024",
        anchor_alignment: "center",
      })
      padIndex++
      params.innerhole &&
        holes.push(
          platedhole(
            padIndex + totalPadsNumber,
            xoff + i * params.p,
            height / 2 - params.innerholeedgedistance,
            innerDiameter,
            outerDiameter,
          ),
        )
    }
  }

  const silkscreenTriangle: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    pcb_silkscreen_path_id: "1",
    pcb_component_id: "1",
    layer: "top",
    route: routes,
    stroke_width: 0.1,
  }

  const silkscreenPath: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    pcb_silkscreen_path_id: "pcb_silkscreen_path_1",
    pcb_component_id: "1",
    route: [
      {
        x: -params.w / 2 - params.pl / 3,
        y: height / 2 + params.pl / 3,
      },
      {
        x: params.w / 2 + params.pl / 3,
        y: height / 2 + params.pl / 3,
      },
      {
        x: params.w / 2 + params.pl / 3,
        y: -height / 2 - params.pl / 3,
      },
      {
        x: -params.w / 2 - params.pl / 3,
        y: -height / 2 - params.pl / 3,
      },
      {
        x: -params.w / 2 - params.pl / 3,
        y: height / 2 + params.pl / 3,
      },
    ],
    stroke_width: 0.1,
    layer: "top",
  }
  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    height / 1.8,
    height / 25,
  )
  return {
    circuitJson: [
      ...holes,
      ...rectpads,
      ...pinLabels,
      silkscreenPath,
      silkscreenTriangle,
      silkscreenRefText,
    ],
    parameters: params,
  }
}

================
File: src/fn/to220.ts
================
import {
  type AnyCircuitElement,
  type PcbSilkscreenPath,
  length,
} from "circuit-json"
import { platedhole } from "src/helpers/platedhole"
import { z } from "zod"
import { type SilkscreenRef, silkscreenRef } from "../helpers/silkscreenRef"

export const to220_def = z.object({
  fn: z.string(),
  p: length.optional().default("5.0mm"),
  id: length.optional().default("1.0mm"),
  od: length.optional().default("1.9mm"),
  w: length.optional().default("13mm"),
  h: length.optional().default("7mm"),
  num_pins: z.number().optional(),
  string: z.string().optional(),
})

export type To220Def = z.input<typeof to220_def>

export const to220 = (
  raw_params: To220Def,
): { circuitJson: AnyCircuitElement[]; parameters: any } => {
  const parameters = to220_def.parse(raw_params)
  const { fn, id, od, w, h, string } = parameters

  const numPins = Number.parseInt(string?.split("_")[1] ?? "3")

  const holeY = -1
  const halfWidth = w / 2
  const halfHeight = h / 2

  const minPitch = 2.5
  const maxHoleWidth = w * 0.4
  const computedPitch = Math.max(minPitch, maxHoleWidth / (numPins - 1))

  const plated_holes = Array.from({ length: numPins }, (_, i) => {
    const x =
      numPins % 2 === 0
        ? (i - numPins / 2 + 0.5) * computedPitch
        : (i - Math.floor(numPins / 2)) * computedPitch
    return platedhole(i + 1, x, holeY, id, od)
  })

  const silkscreenBody: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: -halfWidth, y: -halfHeight },
      { x: halfWidth, y: -halfHeight },
      { x: halfWidth, y: halfHeight },
      { x: -halfWidth, y: halfHeight },
      { x: -halfWidth, y: -halfHeight },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  const yLine = -halfHeight + (2 * h) / 3
  const horizontalLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: -halfWidth, y: yLine },
      { x: halfWidth, y: yLine },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  const verticalLines: PcbSilkscreenPath[] = [
    {
      type: "pcb_silkscreen_path",
      layer: "top",
      pcb_component_id: "",
      route: [
        { x: -w / 6, y: yLine },
        { x: -w / 6, y: halfHeight },
      ],
      stroke_width: 0.1,
      pcb_silkscreen_path_id: "",
    },
    {
      type: "pcb_silkscreen_path",
      layer: "top",
      pcb_component_id: "",
      route: [
        { x: w / 6, y: yLine },
        { x: w / 6, y: halfHeight },
      ],
      stroke_width: 0.1,
      pcb_silkscreen_path_id: "",
    },
  ]

  const silkscreenRefText: SilkscreenRef = silkscreenRef(0, h / 2 + 0.6, 0.5)

  return {
    circuitJson: [
      ...plated_holes,
      silkscreenBody,
      horizontalLine,
      ...verticalLines,
      silkscreenRefText as AnyCircuitElement,
    ],
    parameters: { ...parameters, p: computedPitch },
  }
}

================
File: src/fn/to92.ts
================
import {
  length,
  type AnySoupElement,
  type PcbSilkscreenPath,
} from "circuit-json"
import { z } from "zod"
import { platedhole } from "src/helpers/platedhole"
import { silkscreenRef, type SilkscreenRef } from "../helpers/silkscreenRef"

const generate_semicircle = (
  centerX: number,
  centerY: number,
  radius: number,
) => {
  return Array.from({ length: 25 }, (_, i) => {
    const theta = (i / 24) * Math.PI
    return {
      x: centerX + Math.cos(theta) * radius,
      y: centerY + Math.sin(theta) * radius,
    }
  })
}

export const to92_def = z.object({
  fn: z.string(),
  p: length.optional().default("1.27mm"),
  id: length.optional().default("0.72mm"),
  od: length.optional().default(".95mm"),
  w: length.optional().default("4.5mm"),
  h: length.optional().default("4.5mm"),
  inline: z.boolean().optional().default(false),
})

export type To92Def = z.input<typeof to92_def>

export const to92 = (
  raw_params: To92Def,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = to92_def.parse(raw_params)
  const { p, id, od, w, h, inline } = parameters
  const radius = w / 2
  const holeY = h / 2

  const plated_holes = inline
    ? [
        platedhole(1, -p, holeY - p, id, od),
        platedhole(2, 0, holeY - p, id, od),
        platedhole(3, p, holeY - p, id, od),
      ]
    : [
        platedhole(1, 0, holeY, id, od),
        platedhole(2, -p, holeY - p, id, od),
        platedhole(3, p, holeY - p, id, od),
      ]

  const semicircle = generate_semicircle(0, h / 2, radius)

  const silkscreenBody: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      ...semicircle,
      { x: -radius, y: 0 },
      { x: radius, y: 0 },
      semicircle[0],
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  const silkscreenRefText: SilkscreenRef = silkscreenRef(0, h / 2 + 1, 0.5)

  return {
    circuitJson: [
      ...plated_holes,
      silkscreenBody,
      silkscreenRefText as AnySoupElement,
    ],
    parameters,
  }
}

================
File: src/fn/tssop.ts
================
import type { AnySoupElement } from "circuit-json"
import { extendSoicDef, soicWithoutParsing, type SoicInput } from "./soic"

export const tssop_def = extendSoicDef({
  w: "6.1mm",
  p: "0.65mm",
  legsoutside: true,
})

export const tssop = (
  raw_params: SoicInput,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = tssop_def.parse(raw_params)
  return {
    circuitJson: soicWithoutParsing(parameters),
    parameters,
  }
}

================
File: src/fn/vssop8.ts
================
import type {
  AnySoupElement,
  PcbFabricationNoteText,
  PcbSilkscreenPath,
} from "circuit-json"
import { z } from "zod"
import { rectpad } from "../helpers/rectpad"
import { silkscreenRef, type SilkscreenRef } from "src/helpers/silkscreenRef"
import { length } from "circuit-json"

export const vssop8_def = z.object({
  fn: z.string(),
  num_pins: z.literal(8).default(8),
  w: z.string().default("3.06mm"),
  h: z.string().default("3.14mm"),
  p: z.string().default("0.65mm"),
  pl: z.string().default("1.6mm"),
  pw: z.string().default("0.5mm"),
})

export const vssop8 = (
  raw_params: z.input<typeof vssop8_def>,
): { circuitJson: AnySoupElement[]; parameters: any } => {
  const parameters = vssop8_def.parse(raw_params)

  const pad_spacing = length.parse(parameters.p)

  const silkscreenRefText: SilkscreenRef = silkscreenRef(
    0,
    length.parse(parameters.h) / 2 + 0.5,
    0.3,
  )

  const silkscreenBoxWidth = length.parse(parameters.w)
  const silkscreenBoxHeight = length.parse(parameters.h)

  const silkscreenTopLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: -silkscreenBoxWidth / 2, y: silkscreenBoxHeight / 2 },
      { x: silkscreenBoxWidth / 2, y: silkscreenBoxHeight / 2 },
    ],
    stroke_width: 0.05,
    pcb_silkscreen_path_id: "",
  }

  const silkscreenBottomLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: -silkscreenBoxWidth / 2, y: -silkscreenBoxHeight / 2 },
      { x: silkscreenBoxWidth / 2, y: -silkscreenBoxHeight / 2 },
    ],
    stroke_width: 0.05,
    pcb_silkscreen_path_id: "",
  }

  const pin1Position = getVssop8PadCoord({ pn: 1, pad_spacing })
  const pin1MarkerPosition = {
    x: pin1Position.x - 0.8,
    y: pin1Position.y,
  }
  const pin1Marking: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "pin_marker_1",
    route: [
      { x: pin1MarkerPosition.x - 0.4, y: pin1MarkerPosition.y },
      { x: pin1MarkerPosition.x - 0.7, y: pin1MarkerPosition.y + 0.3 },
      { x: pin1MarkerPosition.x - 0.7, y: pin1MarkerPosition.y - 0.3 },
      { x: pin1MarkerPosition.x - 0.4, y: pin1MarkerPosition.y },
    ],
    stroke_width: 0.05,
    pcb_silkscreen_path_id: "pin_marker_1",
  }

  return {
    circuitJson: getVssop8Pads(parameters, pad_spacing).concat(
      silkscreenTopLine as AnySoupElement,
      silkscreenBottomLine as AnySoupElement,
      silkscreenRefText as AnySoupElement,
      pin1Marking as AnySoupElement,
    ),
    parameters,
  }
}

// Get coordinates for VSSOP-8 pads
export const getVssop8PadCoord = (parameters: {
  pn: number
  pad_spacing: number
}) => {
  const { pn, pad_spacing } = parameters

  const col = pn <= 4 ? -1 : 1

  const row = 1.5 - ((pn - 1) % 4)

  return {
    x: col * length.parse("1.8mm"),
    y: row * pad_spacing,
  }
}

// Generate pads for VSSOP-8
export const getVssop8Pads = (
  parameters: z.infer<typeof vssop8_def>,
  pad_spacing: number,
) => {
  const pads: AnySoupElement[] = []

  for (let i = 1; i <= parameters.num_pins; i++) {
    const { x, y } = getVssop8PadCoord({
      pn: i,
      pad_spacing,
    })
    pads.push(
      rectpad(
        i,
        x,
        y,
        Number.parseFloat(parameters.pl),
        Number.parseFloat(parameters.pw),
      ),
    )
  }
  return pads
}

================
File: src/footprinter.ts
================
import * as FOOTPRINT_FN from "./fn"
import type { AnySoupElement } from "circuit-json"
import type { AnyCircuitElement } from "circuit-json"
import type { AnyFootprinterDefinitionOutput } from "./helpers/zod/AnyFootprinterDefinitionOutput"
import { isNotNull } from "./helpers/is-not-null"
import { footprintSizes } from "./helpers/passive-fn"

export type FootprinterParamsBuilder<K extends string> = {
  [P in K | "params" | "soup" | "circuitJson"]: P extends
    | "params"
    | "soup"
    | "circuitJson"
    ? Footprinter[P]
    : (v?: number | string) => FootprinterParamsBuilder<K>
}

type CommonPassiveOptionKey =
  | "metric"
  | "imperial"
  | "tht"
  | "p"
  | "pw"
  | "ph"
  | "w"
  | "h"

export type Footprinter = {
  dip: (
    num_pins?: number,
  ) => FootprinterParamsBuilder<"w" | "p" | "id" | "od" | "wide" | "narrow">
  cap: () => FootprinterParamsBuilder<CommonPassiveOptionKey>
  res: () => FootprinterParamsBuilder<CommonPassiveOptionKey>
  diode: () => FootprinterParamsBuilder<CommonPassiveOptionKey>
  led: () => FootprinterParamsBuilder<CommonPassiveOptionKey>
  lr: (num_pins?: number) => FootprinterParamsBuilder<"w" | "l" | "pl" | "pr">
  qfp: (
    num_pins?: number,
  ) => FootprinterParamsBuilder<"w" | "p" | "id" | "od" | "wide" | "narrow">
  quad: (
    num_pins?: number,
  ) => FootprinterParamsBuilder<
    "w" | "l" | "square" | "pl" | "pr" | "pb" | "pt" | "p" | "pw" | "ph"
  >
  bga: (
    num_pins?: number,
  ) => FootprinterParamsBuilder<
    "grid" | "p" | "w" | "h" | "ball" | "pad" | "missing"
  >
  qfn: (num_pins?: number) => FootprinterParamsBuilder<"w" | "h" | "p">
  soic: (num_pins?: number) => FootprinterParamsBuilder<"w" | "p" | "id" | "od">
  mlp: (num_pins?: number) => FootprinterParamsBuilder<"w" | "h" | "p">
  ssop: (num_pins?: number) => FootprinterParamsBuilder<"w" | "p">
  tssop: (num_pins?: number) => FootprinterParamsBuilder<"w" | "p">
  dfn: (num_pins?: number) => FootprinterParamsBuilder<"w" | "p">
  pinrow: (
    num_pins?: number,
  ) => FootprinterParamsBuilder<"p" | "id" | "od" | "male" | "female" | "rows">
  axial: () => FootprinterParamsBuilder<"p" | "id" | "od">
  hc49: () => FootprinterParamsBuilder<"p" | "id" | "od" | "w" | "h">
  to220: () => FootprinterParamsBuilder<"w" | "h" | "p" | "id" | "od">
  sot363: () => FootprinterParamsBuilder<"w" | "p" | "pl" | "pw">
  sot563: () => FootprinterParamsBuilder<"w" | "p" | "pl" | "pw">
  sot723: () => FootprinterParamsBuilder<"w" | "h" | "pl" | "pw">
  sot23: () => FootprinterParamsBuilder<"w" | "h" | "pl" | "pw">
  sot89: () => FootprinterParamsBuilder<"w" | "p" | "pl" | "pw" | "h">
  smc: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pw" | "pl">
  minimelf: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pw" | "pl">
  melf: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pw" | "pl">
  micromelf: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pw" | "pl">
  ms013: () => FootprinterParamsBuilder<"w" | "p">
  ms012: () => FootprinterParamsBuilder<"w" | "p">
  lqfp: (num_pins?: number) => FootprinterParamsBuilder<"w" | "h" | "pl" | "pw">
  sma: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pl" | "pw">
  smf: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pl" | "pw">
  smb: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pl" | "pw">
  sod923: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pl" | "pw">
  sod323: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pl" | "pw">
  vssop8: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pl" | "pw">
  sod882: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pl" | "pw">
  sod882d: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pl" | "pw">
  sod723: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pl" | "pw">
  sod523: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pl" | "pw">
  sod323f: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pl" | "pw">
  sod128: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pl" | "pw">
  sod123f: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pl" | "pw">
  sod123: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pl" | "pw">
  sod123w: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pl" | "pw">
  sod110: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pl" | "pw">
  to92: () => FootprinterParamsBuilder<"w" | "h" | "p" | "id" | "od" | "inline">
  sot223: () => FootprinterParamsBuilder<"w" | "h" | "p" | "pl" | "pw">
  pushbutton: () => FootprinterParamsBuilder<
    "tllabel" | "trlabel" | "bllabel" | "brlabel"
  >
  stampboard: () => FootprinterParamsBuilder<
    | "w"
    | "h"
    | "left"
    | "right"
    | "top"
    | "bottom"
    | "p"
    | "pw"
    | "pl"
    | "innerhole"
    | "innerholeedgedistance"
  >
  stampreceiver: () => FootprinterParamsBuilder<
    | "w"
    | "h"
    | "left"
    | "right"
    | "top"
    | "bottom"
    | "p"
    | "pw"
    | "pl"
    | "innerhole"
    | "innerholeedgedistance"
  >
  breakoutheaders: () => FootprinterParamsBuilder<
    "w" | "h" | "left" | "right" | "top" | "bottom" | "p" | "id" | "od"
  >
  pad: () => FootprinterParamsBuilder<"w" | "h"> & {
    params: () => any
    soup: () => AnySoupElement[]
    circuitJson: () => AnyCircuitElement[]
  }

  params: () => any
  /** @deprecated use circuitJson() instead */
  soup: () => AnySoupElement[]
  circuitJson: () => AnyCircuitElement[]
  json: () => AnyFootprinterDefinitionOutput[]
  getFootprintNames: () => string[]
}

export const string = (def: string): Footprinter => {
  let fp = footprinter()

  // special case: 0402, 0603, etc.
  const modifiedDef =
    (def.length === 4 || def.length === 5) && /^\d+$/.test(def)
      ? `res${def}`
      : def

  const def_parts = modifiedDef
    .split("_")
    .map((s) => {
      const m = s.match(/([a-z]+)([\(\d\.\+\?].*)?/)
      const [_, fn, v] = m ?? []
      if (v?.includes("?")) return null
      return { fn: m?.[1]!, v: m?.[2]! }
    })
    .filter(isNotNull)

  for (const { fn, v } of def_parts) {
    fp = fp[fn](v)
  }

  fp.setString(def)

  return fp
}

export const getFootprintNames = (): string[] => {
  return Object.keys(FOOTPRINT_FN)
}

export const getFootprintSizes = (): typeof footprintSizes => {
  return footprintSizes
}

export const getFootprintNamesByType = (): {
  passiveFootprintNames: string[]
  normalFootprintNames: string[]
} => {
  const allFootprintNames = Object.keys(FOOTPRINT_FN)

  const passiveFootprintNames = allFootprintNames.filter((name) => {
    const fn = FOOTPRINT_FN[name]

    return fn.toString().includes("passive(")
  })

  return {
    passiveFootprintNames,
    normalFootprintNames: allFootprintNames.filter(
      (name) => !passiveFootprintNames.includes(name),
    ),
  }
}

export const footprinter = (): Footprinter & {
  string: typeof string
  getFootprintNames: string[]
  setString: (string) => void
} => {
  const proxy = new Proxy(
    {},
    {
      get: (target: any, prop: string) => {
        // console.log(prop, target)
        if (prop === "soup" || prop === "circuitJson") {
          if ("fn" in target && FOOTPRINT_FN[target.fn]) {
            return () => FOOTPRINT_FN[target.fn](target).circuitJson
          }

          if (!FOOTPRINT_FN[target.fn]) {
            throw new Error(
              `Invalid footprint function, got "${target.fn}"${
                target.string ? `, from string "${target.string}"` : ""
              }`,
            )
          }

          return () => {
            // TODO improve error
            throw new Error(
              `No function found for footprinter, make sure to specify .dip, .lr, .p, etc. Got "${prop}"`,
            )
          }
        }
        if (prop === "json") {
          if (!FOOTPRINT_FN[target.fn]) {
            throw new Error(
              `Invalid footprint function, got "${target.fn}"${
                target.string ? `, from string "${target.string}"` : ""
              }`,
            )
          }
          return () => FOOTPRINT_FN[target.fn](target).parameters
        }
        if (prop === "getFootprintNames") {
          return () => Object.keys(FOOTPRINT_FN)
        }
        if (prop === "params") {
          // TODO
          return () => target
        }
        if (prop === "setString") {
          return (v: string) => {
            target.string = v
            return proxy
          }
        }
        return (v: any) => {
          if (Object.keys(target).length === 0) {
            if (`${prop}${v}` in FOOTPRINT_FN) {
              target[`${prop}${v}`] = true
              target.fn = `${prop}${v}`
            } else {
              target[prop] = true
              target.fn = prop
              if (prop === "res" || prop === "cap") {
                if (v) {
                  target.imperial = v // res0402, cap0603 etc.
                }
              } else {
                target.num_pins = Number.isNaN(Number.parseFloat(v))
                  ? undefined
                  : Number.parseFloat(v)
              }
            }
          } else {
            // handle dip_w or other invalid booleans
            if (!v && ["w", "h", "p"].includes(prop as string)) {
              // ignore
            } else {
              target[prop] = v ?? true
            }
          }
          return proxy
        }
      },
    },
  )
  return proxy as any
}
footprinter.string = string
footprinter.getFootprintNames = getFootprintNames

export const fp = footprinter

================
File: src/helpers/corner.ts
================
export const CORNERS = [
  { name: "top-left", dx: -1, dy: 1 },
  { name: "top-right", dx: 1, dy: 1 },
  { name: "bottom-left", dx: -1, dy: -1 },
  { name: "bottom-right", dx: 1, dy: -1 },
]

================
File: src/helpers/get-quad-pin-map.ts
================
import type { PinOrderSpecifier } from "./zod/pin-order-specifier"

/**
 * A counter-clockwise pin map is [1,2,3,4,5,6,7,8] for an 8-pin package
 *
 *     8 7
 *   1     6
 *   2     5
 *     3 4
 *
 * Given some parameters, we're returning how to map the pins in a quad package
 * with a different order. For example, if we pass in cw=true, we'll get the
 * following mapping
 *
 * 1 -> 1
 * 2 -> 8
 * 3 -> 7
 * 4 -> 6
 * 5 -> 5
 * 6 -> 4
 * 7 -> 3
 * 8 -> 2
 *
 * Which allows us to create the CW version of the package using...
 * new_pin = pin_map[normal_ccw_pin]
 *
 *    2 3
 *  1     4
 *  8     5
 *    7 6
 */
export const getQuadPinMap = ({
  num_pins,
  cw,
  ccw,
  startingpin,
}: {
  num_pins: number
  cw?: boolean
  ccw?: boolean
  startingpin?: PinOrderSpecifier[]
}): number[] => {
  const pin_map: number[] = []
  const pins_per_side = num_pins / 4
  let current_position_ccw_normal = 1

  /** Starting Flag Pins */
  const sfp: Record<PinOrderSpecifier, boolean> = {} as any
  for (const specifier of startingpin ?? []) {
    sfp[specifier] = true
  }
  if (!sfp.leftside && !sfp.topside && !sfp.rightside && !sfp.bottomside) {
    sfp.leftside = true
  }
  if (!sfp.bottompin && !sfp.leftpin && !sfp.rightpin && !sfp.toppin) {
    if (sfp.leftside) {
      sfp.toppin = true
    } else if (sfp.topside) {
      sfp.rightpin = true
    } else if (sfp.rightside) {
      sfp.bottompin = true
    } else if (sfp.bottomside) {
      sfp.leftpin = true
    }
  }

  if (sfp.leftside && sfp.toppin) {
    current_position_ccw_normal = 1
  } else if (sfp.leftside && sfp.bottompin) {
    current_position_ccw_normal = pins_per_side
  } else if (sfp.bottomside && sfp.leftpin) {
    current_position_ccw_normal = pins_per_side + 1
  } else if (sfp.bottomside && sfp.rightpin) {
    current_position_ccw_normal = pins_per_side * 2
  } else if (sfp.rightside && sfp.bottompin) {
    current_position_ccw_normal = pins_per_side * 2 + 1
  } else if (sfp.rightside && sfp.toppin) {
    current_position_ccw_normal = pins_per_side * 3
  } else if (sfp.topside && sfp.rightpin) {
    current_position_ccw_normal = pins_per_side * 3 + 1
  } else if (sfp.topside && sfp.leftpin) {
    current_position_ccw_normal = pins_per_side * 4
  }

  pin_map.push(-1) // the first index is meaningless

  // Each iteration we move the current position to the next pin, if we're
  // going CCW this means incrementing, if we're going CW this means
  // decrementing
  for (let i = 0; i < num_pins; i++) {
    pin_map[current_position_ccw_normal] = i + 1
    if (ccw || !cw) {
      current_position_ccw_normal++
      if (current_position_ccw_normal > num_pins) {
        current_position_ccw_normal = 1
      }
    } else {
      current_position_ccw_normal--
      if (current_position_ccw_normal < 1) {
        current_position_ccw_normal = num_pins
      }
    }
  }

  return pin_map
}

================
File: src/helpers/is-not-null.ts
================
export function isNotNull<T>(value: T | null): value is T {
  return value !== null
}

================
File: src/helpers/passive-fn.ts
================
import type {
  AnyCircuitElement,
  AnySoupElement,
  PcbSilkscreenPath,
} from "circuit-json"
import { rectpad } from "../helpers/rectpad"
import mm from "@tscircuit/mm"
import { platedhole } from "./platedhole"
import { z } from "zod"
import { length, distance } from "circuit-json"
import { type SilkscreenRef, silkscreenRef } from "./silkscreenRef"
import { silkscreenpath } from "./silkscreenpath"

type StandardSize = {
  imperial: string
  metric: string
  Z_mm_min: number
  G_mm_min: number
  X_mm_min: number
  C_mm_ref: number
}

// https://www.worthingtonassembly.com/perfect-0201-footprint
// https://static1.squarespace.com/static/54982a02e4b02e9f5e5d9ca7/t/660c692f69a0d83a4afecdf0/1712089391915/Discrete+Component+Footprints.pdf
// https://page.venkel.com/hubfs/Resources/Technical/Resistors%20Landing%20Pattern.pdf
export const footprintSizes = [
  {
    imperial: "01005",
    metric: "0402",
    Z_mm_min: 0.58,
    G_mm_min: 0.18,
    X_mm_min: 0.21,
    C_mm_ref: 0.038,
  },
  {
    imperial: "0201",
    metric: "0603",
    Z_mm_min: 0.9,
    G_mm_min: 0.3,
    X_mm_min: 0.3,
    C_mm_ref: 0.6,
  },
  {
    imperial: "0402",
    metric: "1005",
    Z_mm_min: 1.6,
    G_mm_min: 0.4,
    X_mm_min: 0.7,
    C_mm_ref: 1,
  },
  {
    imperial: "0603",
    metric: "1608",
    Z_mm_min: 2.6,
    G_mm_min: 0.6,
    X_mm_min: 1.0,
    C_mm_ref: 1.7,
  },
  {
    imperial: "0805",
    metric: "2012",
    Z_mm_min: 3.0,
    G_mm_min: 0.6,
    X_mm_min: 1.2,
    C_mm_ref: 1.9,
  },
  {
    imperial: "1206",
    metric: "3216",
    Z_mm_min: 4.2,
    G_mm_min: 1.2,
    X_mm_min: 1.4,
    C_mm_ref: 2.8,
  },
  {
    imperial: "1210",
    metric: "3225",
    Z_mm_min: 3.2,
    G_mm_min: 1.0,
    X_mm_min: 2.5,
    C_mm_ref: 2.0,
  },
  {
    imperial: "2010",
    metric: "5025",
    Z_mm_min: 5.0,
    G_mm_min: 1.2,
    X_mm_min: 2.5,
    C_mm_ref: 3.6,
  },
  {
    imperial: "2512",
    metric: "6332",
    Z_mm_min: 6.3,
    G_mm_min: 1.2,
    X_mm_min: 3.2,
    C_mm_ref: 4.5,
  },
]
const metricMap: Record<string, StandardSize> = footprintSizes.reduce(
  (acc: any, s) => {
    acc[s.metric] = s
    return acc
  },
  {},
)
const imperialMap: Record<string, StandardSize> = footprintSizes.reduce(
  (acc: any, s) => {
    acc[s.imperial] = s
    return acc
  },
  {},
)

export const passive_def = z.object({
  tht: z.boolean(),
  p: length,
  pw: length.optional(),
  ph: length.optional(),
  metric: distance.optional(),
  imperial: distance.optional(),
  w: length.optional(),
  h: length.optional(),
})

export type PassiveDef = z.input<typeof passive_def>

const deriveXFromH = (h: number) => 0.079 * h ** 2 + 0.94 * h - 0.009
const deriveZFromW = (w: number) => 1.09 * w + 0.6
const deriveGFromW = (w: number) => 0.59 * w - 0.31
const deriveCFromW = (w: number) => -0.01 * w ** 2 + 0.94 * w + 0.03

export const passive = (params: PassiveDef): AnySoupElement[] => {
  let { tht, p, pw, ph, metric, imperial, w, h } = params

  if (typeof w === "string") w = mm(w)
  if (typeof h === "string") h = mm(h)
  if (typeof p === "string") p = mm(p)
  if (typeof pw === "string") pw = mm(pw)
  if (typeof ph === "string") ph = mm(ph)

  if (h! > w!) {
    throw new Error(
      "height cannot be greater than width (rotated footprint not yet implemented)",
    )
  }

  /** standard size */
  let sz: StandardSize | undefined
  if (metric) {
    sz = metricMap[metric]
  }

  if (imperial) {
    sz = imperialMap[imperial]
  }

  if (!sz && w && h && !pw && !ph) {
    sz = {
      imperial: "custom",
      metric: "custom",
      Z_mm_min: deriveZFromW(w),
      G_mm_min: deriveGFromW(w),
      X_mm_min: deriveXFromH(h),
      C_mm_ref: deriveCFromW(w),
    }
  }

  if (sz) {
    w = sz.Z_mm_min
    h = sz.X_mm_min
    p = sz.C_mm_ref
    pw = (sz.Z_mm_min - sz.G_mm_min) / 2
    ph = (sz.Z_mm_min - sz.G_mm_min) / 2
  }

  if (pw === undefined) throw new Error("could not infer pad width")
  if (ph === undefined) throw new Error("could not infer pad width")

  const silkscreenLine: PcbSilkscreenPath = {
    type: "pcb_silkscreen_path",
    layer: "top",
    pcb_component_id: "",
    route: [
      { x: p / 2, y: ph / 2 + 0.4 },
      { x: -p / 2 - pw / 2 - 0.2, y: ph / 2 + 0.4 },
      { x: -p / 2 - pw / 2 - 0.2, y: -ph / 2 - 0.4 },
      { x: p / 2, y: -ph / 2 - 0.4 },
    ],
    stroke_width: 0.1,
    pcb_silkscreen_path_id: "",
  }

  const silkscreenRefText: SilkscreenRef = silkscreenRef(0, ph / 2 + 0.9, 0.2)

  if (tht) {
    return [
      platedhole(1, -p / 2, 0, pw, (pw * 1) / 0.8),
      platedhole(2, p / 2, 0, pw, (pw * 1) / 0.8),
      silkscreenLine,
      silkscreenRefText,
    ]
  } else {
    return [
      rectpad(["1", "left"], -p / 2, 0, pw, ph),
      rectpad(["2", "right"], p / 2, 0, pw, ph),
      silkscreenLine,
      silkscreenRefText,
    ]
  }
}

================
File: src/helpers/platedhole.ts
================
import type { PcbPlatedHole } from "circuit-json"
import { mm } from "@tscircuit/mm"

export const platedhole = (
  pn: number,
  x: number,
  y: number,
  id: number | string,
  od: number | string,
): PcbPlatedHole => {
  return {
    pcb_plated_hole_id: "",
    type: "pcb_plated_hole",
    shape: "circle",
    x,
    y,
    hole_diameter: mm(id),
    outer_diameter: mm(od),
    pcb_port_id: "",
    layers: ["top", "bottom"],
    port_hints: [pn.toString()],
  }
}

================
File: src/helpers/rectpad.ts
================
import type { PCBSMTPad } from "circuit-json"
export const rectpad = (
  pn: number | Array<string | number>,
  x: number,
  y: number,
  w: number,
  h: number,
): PCBSMTPad => {
  return {
    type: "pcb_smtpad",
    x,
    y,
    width: w,
    height: h,
    layer: "top",
    shape: "rect",
    pcb_smtpad_id: "",
    port_hints: Array.isArray(pn)
      ? pn.map((item) => item.toString())
      : [pn.toString()],
  }
}

================
File: src/helpers/silkscreenpath.ts
================
import type { PcbSilkscreenPath } from "circuit-json"

export const silkscreenpath = (
  route: Array<{ x: number; y: number }>,
  options: {
    stroke_width?: number
    layer?: string
    pcb_component_id?: string
    pcb_silkscreen_path_id?: string
  } = {},
): PcbSilkscreenPath => {
  return {
    type: "pcb_silkscreen_path",
    layer: options.layer || "top",
    pcb_component_id: options.pcb_component_id || "",
    pcb_silkscreen_path_id: options.pcb_silkscreen_path_id || "",
    route,
    stroke_width: options.stroke_width || 0.1,
  }
}

================
File: src/helpers/silkscreenRef.ts
================
import type { PcbSilkscreenText } from "circuit-json"

export const silkscreenRef: (
  x: number,
  y: number,
  font_size: number,
) => PcbSilkscreenText = (x: number, y: number, font_size: number) => {
  return {
    type: "pcb_silkscreen_text",
    pcb_silkscreen_text_id: "silkscreen_text_1",
    font: "tscircuit2024",
    font_size: font_size,
    pcb_component_id: "pcb_component_1",
    text: "{REF}",
    layer: "top",
    anchor_position: { x: x, y: y },
    anchor_alignment: "center",
  }
}
export type SilkscreenRef = ReturnType<typeof silkscreenRef>

================
File: src/helpers/u-curve.ts
================
export const u_curve = Array.from({ length: 9 }, (_, i) =>
  Math.cos((i / 8) * Math.PI - Math.PI),
).map((x) => ({
  x,
  y: -Math.sqrt(1 - x ** 2),
}))

================
File: src/helpers/zod/ALPHABET.ts
================
export const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

================
File: src/helpers/zod/AnyFootprinterDefinitionOutput.ts
================
import { z } from "zod"
import { axial_def } from "src/fn/axial"
import { bga_def } from "src/fn/bga"
import { dfn_def } from "src/fn/dfn"
import { dip_def } from "src/fn/dip"
import { mlp_def } from "src/fn/mlp"
import { ms012_def } from "src/fn/ms012"
import { ms013_def } from "src/fn/ms013"
import { pinrow_def } from "src/fn/pinrow"
import { qfn_def } from "src/fn/qfn"
import { qfp_def } from "src/fn/qfp"
import { quad_def } from "src/fn/quad"
import { sod_def } from "src/fn/sod123"
import { soic_def } from "src/fn/soic"
import { sot23_def } from "src/fn/sot23"
import { sot363_def } from "src/fn/sot363"
import { sot563_def } from "src/fn/sot563"
import { sot723_def } from "src/fn/sot723"
import { ssop_def } from "src/fn/ssop"
import { tssop_def } from "src/fn/tssop"
import { passive_def } from "../passive-fn"
import { pad_def } from "../../fn/pad"

export const any_footprinter_def = z.union([
  axial_def,
  bga_def,
  dfn_def,
  dip_def,
  mlp_def,
  ms012_def,
  ms013_def,
  pinrow_def,
  qfn_def,
  qfp_def,
  quad_def,
  sod_def,
  soic_def,
  sot23_def,
  sot363_def,
  sot563_def,
  sot723_def,
  ssop_def,
  tssop_def,
  passive_def,
  pad_def,
])

export type AnyFootprinterDefinitionOutput = z.infer<typeof any_footprinter_def>

================
File: src/helpers/zod/dim-2d.ts
================
import { z } from "zod"

export const dim2d = z
  .string()
  .transform((a) => {
    const [x, y] = a.split(/[x ]/)
    return {
      x: parseFloat(x),
      y: parseFloat(y),
    }
  })
  .pipe(
    z.object({
      x: z.number(),
      y: z.number(),
    }),
  )

================
File: src/helpers/zod/function-call.ts
================
import { z } from "zod"

export const function_call = z
  .string()
  .or(z.array(z.any()))
  .transform((a) => {
    if (Array.isArray(a)) return a
    if (a.startsWith("(") && a.endsWith(")")) {
      a = a.slice(1, -1)
    }
    return a.split(",").map((v) => {
      const numVal = Number(v)
      return isNaN(numVal) ? v : numVal
    })
  })
  .pipe(z.array(z.string().or(z.number())))

================
File: src/helpers/zod/now-defined.ts
================
/* Define a utility type to make certain keys required */
export type NowDefined<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>

================
File: src/helpers/zod/pin-order-specifier.ts
================
import { z } from "zod"
export const pin_order_specifier = z.enum([
  "leftside",
  "topside",
  "rightside",
  "bottomside",
  "toppin",
  "bottompin",
  "leftpin",
  "rightpin",
])

export type PinOrderSpecifier = z.infer<typeof pin_order_specifier>

================
File: src/index.ts
================
export * from "./footprinter"

================
File: tests/axial.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("axial_p0.2in", () => {
  const soup = fp.string("axial_p0.2in").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "axial_p0.2in")
})

================
File: tests/bga.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("bga footprint", () => {
  const soup = fp()
    .bga(8)
    .w("4mm")
    .h("4mm")
    .grid("3x3")
    .missing("center")
    .p(1)
    .soup()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "bga footprint")
})

test("bga7_w8_h8_grid3x3_p1_missing(center,B1)", () => {
  const soup = fp
    .string("bga7_w8_h8_grid3x3_p1_missing(center,B1)")
    .circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "bga7_w8_h8_grid3x3_p1_missing(center,B1)",
  )
})

test("bga64_w10_h10_grid8x8_p1.27mm", () => {
  const soup = fp()
    .bga(64)
    .w("10mm")
    .h("10mm")
    .grid("8x8")
    .missing("center")
    .p(1.27)
    .soup()
  // 16pins, 4mm x 4mm, 8x8 grid, 1.27mm pitch
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "bga64_w10_h10_grid8x8_p1.27mm",
  )
})

================
File: tests/breakoutheaders.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("breakoutheaders", () => {
  const soup = fp
    .string("breakoutheaders_left15_right15_w8mm_p1.54mm")
    .circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "breakoutheaders_left20_right20_w8mm_p2.54mm",
  )
})

================
File: tests/cap.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("cap footprint", () => {
  const soup = fp().cap().imperial("0402").soup()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "cap footprint")
})

test("cap_imperial0402", () => {
  const soup = fp.string("cap_imperial0402").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "cap_imperial0402")
})
test("cap 1210", () => {
  const soup = fp.string("1210").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "cap_1210")
})

================
File: tests/dfn.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("dfn8_w5.3mm_p1.27mm", () => {
  const soup = fp.string("dfn8_w5.3mm_p1.27mm").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "dfn8_w5.3mm_p1.27mm")
})

================
File: tests/diode.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("diode", () => {
  const soup = fp().diode().imperial("0402").soup()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "diode")
})

test("diode0402", () => {
  const soup = fp.string("0402").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "diode0402")
})

test("diode1210", () => {
  const soup = fp().diode().imperial("1210").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "diode1210")
})

test("diode0603", () => {
  const soup = fp().diode().imperial("0603").soup()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "diode0603")
})

================
File: tests/dip.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"
import type { AnyCircuitElement } from "circuit-json"

test("dip footprint", () => {
  const circuitJson = fp().dip(4).w(4).p(2).circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "dip footprint")
})

test("dip16", () => {
  const circuitJson = fp.string("dip16").circuitJson() as AnyCircuitElement[]
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "dip16")
})

test("dip4_w3.00mm", () => {
  const circuitJson = fp
    .string("dip4_w3.00mm")
    .circuitJson() as AnyCircuitElement[]
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "dip4_w3.00mm")
})
test("dip10_w4.00mm_p2.65mm", () => {
  const circuitJson = fp
    .string("dip10_w4.00mm_p2.65mm")
    .circuitJson() as AnyCircuitElement[]
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "dip10_w4.00mm_p2.65mm",
  )
})

test("dip4", () => {
  const circuitJson = fp.string("dip4").circuitJson() as AnyCircuitElement[]
  const json = fp.string("dip4").json()

  expect(json).toMatchInlineSnapshot(
    {
      fn: "dip",
      id: 1,
      num_pins: 4,
      od: 1.5,
      p: 2.54,
      w: 7.62,
    },
    `
{
  "fn": "dip",
  "id": 1,
  "num_pins": 4,
  "od": 1.5,
  "p": 2.54,
  "w": 7.62,
}
`,
  )

  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "dip4")
})

test("dip8_p1.27mm", () => {
  const circuitJson = fp.string("dip8_p1.27mm").circuitJson()
  let svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "dip8_p1.27mm")
})

test("dip14_w7.62mm_p2.54mm", () => {
  const circuitJson = fp
    .string("dip14_w7.62mm_p2.54mm")
    .circuitJson() as AnyCircuitElement[]
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "dip14_w7.62mm_p2.54mm",
  )
})

test("dip_0.1in", () => {
  const circuitJson = fp
    .string("dip_0.1in")
    .circuitJson() as AnyCircuitElement[]
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "dip_0.1in")
})

================
File: tests/fixtures/get-test-fixture.ts
================
import { logSoup } from "@tscircuit/log-soup"
import type { AnyCircuitElement } from "circuit-json"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import fs from "node:fs"
import path from "node:path"
import { fp } from "../../src/footprinter"

export const getTestFixture = async (testName: string) => {
  const outputDir = path.join(__dirname, "../__snapshots__")
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true })
  }

  const snapshotSoup = (soup: AnyCircuitElement[]) => {
    const outputPath = path.join(outputDir, `${testName}.svg`)
    const svg = convertCircuitJsonToPcbSvg(soup)
    fs.writeFileSync(outputPath, svg)
  }

  return {
    fp,
    logSoup: (soup: AnyCircuitElement[]) => {
      if (process.env.CI || process.env.FULL_RUN) return
      return logSoup(`footprinter: ${testName}`, soup)
    },
    logSoupWithPrefix: (prefix: string, soup: AnyCircuitElement[]) => {
      if (process.env.CI || process.env.FULL_RUN) return
      return logSoup(`footprinter: ${testName} ${prefix}`, soup)
    },
    snapshotSoup,
  }
}

================
File: tests/fixtures/index.ts
================
import type { AnySoupElement } from "circuit-json"

export { getTestFixture } from "./get-test-fixture"

export const toPinPositionString = (soup: AnySoupElement[]) => {
  return soup
    .map((e: AnySoupElement) => {
      if (e.type === "pcb_plated_hole") {
        return {
          x: e.x,
          y: e.y,
          pn: e.port_hints?.[0],
        }
      } else if (e.type === "pcb_smtpad") {
        return {
          x: e.x,
          y: e.y,
          pn: e.port_hints?.[0],
        }
      }
      // TODO other types
    })
    .filter(Boolean)
    .sort((a: any, b: any) => a.pn - b.pn)
    .map(
      (e: any) =>
        `${e.pn.padEnd(2)}: ${e.x.toFixed(2).padStart(5)} ${e.y
          .toFixed(2)
          .padStart(5)}`,
    )
    .join("\n")
}

================
File: tests/fixtures/preload.ts
================
import "bun-match-svg"

================
File: tests/footprint-completeness.test.ts
================
import { describe, expect, it } from "bun:test"
import { getFootprintNames } from "../src/footprinter"
import fs from "fs"
import path from "path"

describe("footprint completeness", () => {
  it("should expose all footprint functions from src/fn/", () => {
    const fnDir = path.join(process.cwd(), "src", "fn")
    const footprintFiles = fs
      .readdirSync(fnDir)
      .filter((file) => file.endsWith(".ts") && file !== "index.ts")
      .map((file) => path.basename(file, ".ts"))

    const exposedFootprints = getFootprintNames()

    for (const file of footprintFiles) {
      expect(exposedFootprints.includes(file)).toBe(true)
    }

    for (const footprint of exposedFootprints) {
      expect(footprintFiles.includes(footprint)).toBe(true)
    }

    expect(footprintFiles.length).toBe(exposedFootprints.length)
  })
})

================
File: tests/fp-string-error.test.ts
================
import { test, expect } from "bun:test"
import { fp } from "src/footprinter"

test("fp.string error", () => {
  expect(() => fp.string("nonexistentfn4_p3").circuitJson()).toThrow(
    'Invalid footprint function, got "nonexistentfn", from string "nonexistentfn4_p3"',
  )
})

================
File: tests/get-footprint-names.test.ts
================
import { test, expect } from "bun:test"
import { getFootprintNames, getFootprintNamesByType } from "../src/footprinter"

test("getFootprintNames returns all footprint names", () => {
  const footprintNames = getFootprintNames()
  expect(footprintNames).toContain("res")
  expect(footprintNames).toContain("cap")
  expect(footprintNames).toContain("dip")
  expect(footprintNames).toContain("soic")
})

test("getFootprintNamesByType groups footprint names by component type", () => {
  const { passiveFootprintNames, normalFootprintNames } =
    getFootprintNamesByType()

  expect(passiveFootprintNames).toContain("res")
  expect(passiveFootprintNames).toContain("cap")
  expect(passiveFootprintNames).toContain("diode")
  expect(passiveFootprintNames).toContain("led")

  expect(normalFootprintNames).toContain("dip")
  expect(normalFootprintNames).toContain("soic")
  expect(normalFootprintNames).toContain("qfp")
  expect(normalFootprintNames).not.toContain("res")
  expect(normalFootprintNames).not.toContain("cap")
  expect(normalFootprintNames).not.toContain("diode")
  expect(normalFootprintNames).not.toContain("led")
})

================
File: tests/hc49.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("hc49", () => {
  const soup = fp.string("hc49").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)

  // Ensure soup is not empty or undefined
  expect(soup).toBeDefined()
  expect(soup.length).toBeGreaterThan(0)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "hc49")
})

================
File: tests/led.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { led } from "../src/fn"
import { fp } from "../src/footprinter"

test("led_rect", () => {
  const soup = led({
    tht: false,
    p: 2.5,
    pw: 0.5,
    ph: 0.5,
  }).circuitJson

  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "led_rect")
})
test("led_hole", () => {
  const soup = led({
    tht: true,
    p: 2,
    pw: 0.5,
    ph: 0.5,
    metric: "mm",
    w: 5,
    h: 2,
  }).circuitJson

  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "led_hole")
})

test("led_rect testing .parameters for .json", async () => {
  const params = {
    tht: false,
    p: 2.5,
    pw: 0.5,
    ph: 0.5,
  }

  const soup = led(params)

  const soupJson = soup.circuitJson
  const soupParameters = soup.parameters

  const svgContent = convertCircuitJsonToPcbSvg(soupJson)

  expect(soupParameters).toEqual(params)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "led_rect")
})

test("led_hole testing .parameters for .json", async () => {
  const params = {
    tht: true,
    p: 2,
    pw: 0.5,
    ph: 0.5,
    metric: "mm",
    w: 5,
    h: 2,
  }

  const soup = led(params)

  const soupJson = soup.circuitJson
  const soupParameters = soup.parameters

  const svgContent = convertCircuitJsonToPcbSvg(soupJson)

  expect(soupParameters).toEqual(params)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "led_hole")
})

test("led0402", () => {
  const soup = fp.string("0402").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "led_0402")
})

test("led0603", () => {
  const soup = fp.string("0603").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "led_0603")
})

test("led0805", () => {
  const soup = fp.string("0805").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "led_0805")
})

test("led1206", () => {
  const soup = fp().led().imperial("1206").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "led_1206")
})

================
File: tests/lqfp.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("lqfp64_w10_h10_pl1_pw0.25mm", () => {
  const soup = fp.string("lqfp64_w10_h10_pl1_pw0.25mm").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "lqfp64_w10_h10_pl1_pw0.25mm",
  )
})

================
File: tests/melf.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("melf", () => {
  const circuitJson = fp.string("melf").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "melf")
})

================
File: tests/micromelf.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("micromelf", () => {
  const circuitJson = fp.string("micromelf").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "micromelf")
})

================
File: tests/minimelf.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("minimelf", () => {
  const circuitJson = fp.string("minimelf").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "minimelf")
})

================
File: tests/mlp.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("mlp16_w4_h4_p0.5mm", () => {
  const soup = fp.string("mlp16_w4_h4_p0.5mm").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "mlp16_w4_h4_p0.5mm")
})

================
File: tests/ms012.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("ms012", () => {
  const soup = fp.string("ms012").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "ms012")
})

================
File: tests/ms013.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("ms013", () => {
  const soup = fp.string("ms013").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "ms013")
})

================
File: tests/pad.test.ts
================
import { expect, test } from "bun:test"
import { fp } from "../src/footprinter"
import { getTestFixture } from "./fixtures/get-test-fixture"

test("pad footprint", async () => {
  const { snapshotSoup } = await getTestFixture("pad")
  const soup = fp().pad().w(2).h(1).circuitJson()
  expect(soup).toMatchInlineSnapshot(`
[
  {
    "height": 1,
    "layer": "top",
    "pcb_smtpad_id": "",
    "port_hints": [
      "1",
    ],
    "shape": "rect",
    "type": "pcb_smtpad",
    "width": 2,
    "x": 0,
    "y": 0,
  },
  {
    "anchor_alignment": "center",
    "anchor_position": {
      "x": 0,
      "y": 1,
    },
    "font": "tscircuit2024",
    "font_size": 0.2,
    "layer": "top",
    "pcb_component_id": "pcb_component_1",
    "pcb_silkscreen_text_id": "silkscreen_text_1",
    "text": "{REF}",
    "type": "pcb_silkscreen_text",
  },
]
`)
  snapshotSoup(soup)
})

test("pad footprint with different dimensions", async () => {
  const { snapshotSoup } = await getTestFixture("pad_3x2")
  const soup = fp().pad().w(3).h(2).circuitJson()
  expect(soup).toMatchInlineSnapshot(`
[
  {
    "height": 2,
    "layer": "top",
    "pcb_smtpad_id": "",
    "port_hints": [
      "1",
    ],
    "shape": "rect",
    "type": "pcb_smtpad",
    "width": 3,
    "x": 0,
    "y": 0,
  },
  {
    "anchor_alignment": "center",
    "anchor_position": {
      "x": 0,
      "y": 1.5,
    },
    "font": "tscircuit2024",
    "font_size": 0.2,
    "layer": "top",
    "pcb_component_id": "pcb_component_1",
    "pcb_silkscreen_text_id": "silkscreen_text_1",
    "text": "{REF}",
    "type": "pcb_silkscreen_text",
  },
]
`)
  snapshotSoup(soup)
})

================
File: tests/pinrow.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("pinrow5", () => {
  const soup = fp.string("pinrow5").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  const pinrowJson = fp.string("pinrow5_female").json()
  expect(pinrowJson).toMatchObject({
    fn: "pinrow",
    num_pins: 5,
    p: 2.54,
    id: 1,
    od: 1.5,
    female: true,
    male: false,
  })
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "pinrow5")
})

test("pinrow4_rows2", () => {
  const circuitJson = fp.string("pinrow4_rows2").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)

  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "pinrow4_rows2")
})

test("pinrow8_rows4", () => {
  const circuitJson = fp.string("pinrow8_rows4").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)

  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "pinrow8_rows4")
})

test("pinrow9_male_rows3", () => {
  const circuitJson = fp.string("pinrow9_male_rows3").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)

  const pinrowJson = fp.string("pinrow9_male_rows3").json()

  expect(pinrowJson).toMatchObject({
    fn: "pinrow",
    num_pins: 9,
    p: 2.54,
    id: 1,
    od: 1.5,
    male: true,
    female: false,
    rows: 3,
  })

  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "pinrow9_male_rows3")
})

test("pinrow6_female_rows2", () => {
  const circuitJson = fp.string("pinrow6_female_rows2").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)

  const pinrowJson = fp.string("pinrow6_female_rows2").json()

  expect(pinrowJson).toMatchObject({
    fn: "pinrow",
    num_pins: 6,
    p: 2.54,
    id: 1,
    od: 1.5,
    male: false,
    female: true,
    rows: 2,
  })

  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "pinrow6_female_rows2",
  )
})

================
File: tests/pushbutton.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("pushbutton", () => {
  const circuitJson = fp.string("pushbutton").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "pushbutton")
})

================
File: tests/qfn.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("qfn16_w4_h4_p0.65mm", () => {
  const soup = fp.string("qfn16_w4_h4_p0.65mm").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "qfn16_w4_h4_p0.65mm")
})

================
File: tests/qfp.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("qfp48_w14_p1mm", () => {
  const soup = fp.string("qfp48_w14_p1mm").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "qfp48_w14_p1mm")
})

test("qfp48_w14_p1mm_startingpin(topside,leftpin)", () => {
  const soup = fp
    .string("qfp48_w14_p1mm_startingpin(topside,leftpin)")
    .circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "qfp48_w14_p1mm_startingpin(topside,leftpin)",
  )
})

test("qfp80_w14_h14_p0.65mm", () => {
  const soup = fp
    .string("qfp80_w14_h14_p0.65mm_startingpin(topside,leftpin)")
    .circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "qfp80_w14_h14_p0.65mm_startingpin(topside,leftpin)",
  )
})
test("qfp52", () => {
  const soup = fp.string("qfp52").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "qfp52")
})

================
File: tests/quad-custom-thermalpad.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("quad16_w4_l4_p0.4_pw0.25_pl0.4_thermalpad1.5mmx1mm", () => {
  const soup = fp
    .string("quad16_w4_l4_p0.4_pw0.25_pl0.4_thermalpad1.5mmx1mm")
    .circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path)
})

================
File: tests/quad.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("quad16_w4_l4_p0.4_pw0.25_pl0.4", () => {
  const soup = fp.string("quad16_w4_l4_p0.4_pw0.25_pl0.4").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "quad16_w4_l4_p0.4_pw0.25_pl0.4",
  )
})

test("quad16_w4_l4_p0.4_pw0.25_pl0.4_thermalpad_startingpin(bottomside,leftpin)", () => {
  const soup = fp
    .string(
      "quad16_w4_l4_p0.4_pw0.25_pl0.4_thermalpad_startingpin(bottomside,leftpin)",
    )
    .circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "quad16_w4_l4_p0.4_pw0.25_pl0.4_thermalpad_startingpin(bottomside,leftpin)",
  )
})

================
File: tests/res.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("0402", () => {
  const soup = fp.string("0402").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "0402")
})

================
File: tests/slop/slop1.test.ts
================
import { describe, it, expect } from "bun:test" // Bun's test utilities
import { getTestFixture } from "../fixtures" // Adjust path based on your structure
import type { AnyCircuitElement } from "circuit-json"

// biome-ignore lint/suspicious/noExportsInTest: <explanation>
export const SLOP_LIST = [
  "dip3",
  "bga64",
  "bga48",
  "bga48_grid8x8",
  "bga48_p2_pad0.2",
  "qfn32_p0.5mm",
  "pad_w2_h1",
]

describe("Slop Tests", () => {
  it("should handle slop elements correctly", async () => {
    const { fp, logSoupWithPrefix } = await getTestFixture("slop1")

    const soups: AnyCircuitElement[][] = []
    const failures: Array<{
      slop_string: string
      error: any
    }> = []

    for (const slop of SLOP_LIST) {
      try {
        const soup = fp.string(slop).soup()
        soups.push(soup)
        if (slop === SLOP_LIST[SLOP_LIST.length - 1]) {
          await logSoupWithPrefix(slop, soup)
        }
      } catch (e: any) {
        failures.push({
          slop_string: slop,
          error: e,
        })
        throw console.error(e)
      }
    }

    // Check if there were any failures and log the message
    if (failures.length > 0) {
      throw new Error(
        `Failures:\n${failures.map((f) => f.slop_string).join("\n")}`,
      )
      // biome-ignore lint/style/noUselessElse: <explanation>
    } else {
      expect(failures.length).toBe(0) // Assert that there are no failures
    }
  })
})

================
File: tests/sma.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sma", () => {
  const circuitJson = fp.string("sma").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sma")
})

================
File: tests/smb.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("smb", () => {
  const circuitJson = fp.string("smb").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "smb")
})

================
File: tests/smc.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("smc", () => {
  const circuitJson = fp.string("smc").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "smc")
})

================
File: tests/smf.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("smf", () => {
  const circuitJson = fp.string("smf").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "smf")
})

================
File: tests/sod110.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sod110", () => {
  const circuitJson = fp.string("sod110").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sod110")
})

================
File: tests/sod123.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sod123", () => {
  const soup = fp.string("sod123").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sod123")
})

================
File: tests/sod123f.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sod123f", () => {
  const circuitJson = fp.string("sod123f").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sod123f")
})

================
File: tests/sod123w.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sod123w", () => {
  const circuitJson = fp.string("sod123w").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sod123w")
})

================
File: tests/sod128.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sod128", () => {
  const circuitJson = fp.string("sod128").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sod128")
})

================
File: tests/sod323.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sod323", () => {
  const circuitJson = fp.string("sod323").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sod323")
})

================
File: tests/sod323f.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sod323f", () => {
  const circuitJson = fp.string("sod323f").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sod323f")
})

================
File: tests/sod523.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sod523", () => {
  const soup = fp.string("sod523").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sod523")
})

================
File: tests/sod723.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sod723", () => {
  const circuitJson = fp.string("sod723").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sod723")
})

================
File: tests/sod882.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sod882", () => {
  const circuitJson = fp.string("sod882").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sod882")
})

================
File: tests/sod882d.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sod882d", () => {
  const circuitJson = fp.string("sod882d").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sod882d")
})

================
File: tests/sod923.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sod923", () => {
  const circuitJson = fp.string("sod923").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sod923")
})

================
File: tests/soic.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("soic8_w5.3mm_p1.27mm", () => {
  const soup = fp.string("soic8_w5.3mm_p1.27mm").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "soic8_w5.3mm_p1.27mm",
  )
})

================
File: tests/sop8.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sop8", () => {
  const soup = fp.string("sop8").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sop8")
})

================
File: tests/sot223.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sot223_4", () => {
  const circuitJson = fp.string("sot223_4").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sot223_4")
})
test("sot223", () => {
  const circuitJson = fp.string("sot223").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sot223")
})

test("sot223_5", () => {
  const circuitJson = fp.string("sot223_5").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sot223_5")
})
test("sot223_6", () => {
  const circuitJson = fp.string("sot223_6").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sot223_6")
})

================
File: tests/sot23.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sot23", () => {
  const circuitJson = fp.string("sot23").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sot23")
})
test("sot23_w3_h1.5_p0.95mm", () => {
  const circuitJson = fp.string("sot23_w3_h1.5_p0.95mm").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "sot23_w3_h1.5_p0.95mm",
  )
})
test("sot23_3", () => {
  const circuitJson = fp.string("sot23_3").circuitJson()

  const smtpad = circuitJson.filter((e) => e.type === "pcb_smtpad")
  expect(smtpad).toBeDefined()
  expect(smtpad.length).toBe(3)

  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sot23_3")
})

test("sot23_5", () => {
  const circuitJson = fp.string("sot23_5").circuitJson()

  const smtpad = circuitJson.filter((e) => e.type === "pcb_smtpad")
  expect(smtpad).toBeDefined()
  expect(smtpad.length).toBe(5)

  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sot23_5")
})

test("sot23_6", () => {
  const circuitJson = fp.string("sot23_6").circuitJson()

  const smtpad = circuitJson.filter((e) => e.type === "pcb_smtpad")
  expect(smtpad).toBeDefined()
  expect(smtpad.length).toBe(6)

  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sot23_6")
})

================
File: tests/sot363.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sot363", () => {
  const soup = fp.string("sot363").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sot363")
})

================
File: tests/sot563.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sot563", () => {
  const soup = fp.string("sot563").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sot563")
})

================
File: tests/sot723.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sot723", () => {
  const soup = fp.string("sot723").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sot723")
})

================
File: tests/sot89.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("sot89_3", () => {
  const circuitJson = fp.string("sot89_3").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sot89_3")
})
test("sot89_5", () => {
  const circuitJson = fp.string("sot89_5").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "sot89_5")
})

================
File: tests/ssop.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("ssop", () => {
  const soup = fp.string("ssop4").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "ssop")
})

================
File: tests/stampboard.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("stampboard", () => {
  const soup = fp
    .string("stampboard_left20_right20_bottom3_top2_w21mm_p2.54mm_innerhole")
    .circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "stampboard_left20_right20_bottom3_top2_w21mm_p2.54mm_innerhole",
  )
})
test("stampboard", () => {
  const soup = fp
    .string("stampboard_left10_right10_bottom4_top0_w21mm_p2.54mm")
    .circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "stampboard_left10_right10_bottom4_top0_w21mm_p2.54mm",
  )
})

================
File: tests/stampreceiver.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("stampreceiver", () => {
  const soup = fp
    .string("stampreceiver_left20_right20_bottom3_top2_w21mm_p2.54mm")
    .circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "stampreceiver_left20_right20_bottom3_top2_w21mm_p2.54mm",
  )
})

test("stampreceiver", () => {
  const soup = fp
    .string("stampreceiver_left20_right20_bottom3_top2_w21mm_p2.54mm_innerhole")
    .circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "stampreceiver_left20_right20_bottom3_top2_w21mm_p2.54mm_innerhole",
  )
})

================
File: tests/to220.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "src/footprinter"

test("to220_2 (2 holes)", () => {
  const circuitjson = fp.string("to220_2").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitjson)

  expect(circuitjson).toBeDefined()
  expect(circuitjson.length).toBeGreaterThan(0)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "to220_2")
})

test("to220_3 (3 holes)", () => {
  const circuitjson = fp.string("to220_3").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitjson)

  expect(circuitjson).toBeDefined()
  expect(circuitjson.length).toBeGreaterThan(0)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "to220_3")
})
test("to220_4 (4 holes)", () => {
  const circuitjson = fp.string("to220_4").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitjson)

  expect(circuitjson).toBeDefined()
  expect(circuitjson.length).toBeGreaterThan(0)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "to220_4")
})

test("to220_5 (5 holes)", () => {
  const circuitJson = fp.string("to220_5").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "to220_5")
})

================
File: tests/to92.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("to92 (triangular)", () => {
  const circuitJson = fp.string("to92").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path)
})

test("to92_inline (inline)", () => {
  const circuitJson = fp.string("to92_inline").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "to92_inline")
})

================
File: tests/tssop.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("tssop", () => {
  const soup = fp.string("tssop8_w5.3mm_p1.27mm").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "tssop8_w5.3mm_p1.27mm",
  )
})

test("tssop20_w6.5mm_p0.65mm", () => {
  const soup = fp.string("tssop20_w6.5mm_p0.65mm").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(soup)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "tssop20_w6.5mm_p0.65mm",
  )
})

================
File: tests/vssop8.test.ts
================
import { test, expect } from "bun:test"
import { convertCircuitJsonToPcbSvg } from "circuit-to-svg"
import { fp } from "../src/footprinter"

test("vssop8", () => {
  const circuitJson = fp.string("vssop8_p0.65mm").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "vssop8_p0.65mm")
})

test("vssop8_w4.1mm_h4.14mm_p0.65mm", () => {
  const circuitJson = fp.string("vssop8_w4.1mm_h4.14mm_p0.65mm").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "vssop8_w4.1mm_h4.14mm_p0.65mm",
  )
})

test("vssop8_p0.75mm", () => {
  const circuitJson = fp.string("vssop8_p0.75mm").circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(import.meta.path, "vssop8_p0.75mm")
})

test("vssop8_h4.14mm_pl1.8mm_pw0.8mm_p1mm", () => {
  const circuitJson = fp
    .string("vssop8_h4.14mm_pl1.8mm_pw0.8mm_p1mm")
    .circuitJson()
  const svgContent = convertCircuitJsonToPcbSvg(circuitJson)
  expect(svgContent).toMatchSvgSnapshot(
    import.meta.path,
    "vssop8_h4.14mm_pl1.8mm_pw0.8mm_p1mm",
  )
})



================================================================
End of Codebase
================================================================
